Sign up Sign in
Explore
Features
Enterprise
Blog

This repository
Star 0 Fork 2 PUBLIC pa3ang/Tentec506
Browse code
Used Libraries
 master
commit 5a843cc14451010b9e1719abe62bea7c9eb36d53 1 parent 14acec3
 pa3ang authored 9 days ago
Showing 33 changed files with 6,909 additions and 0 deletions. Show Diff Stats
BIN ?????  lib/IOShieldOled/IOShield Library - Oeld.doc View file @ 5a843cc
Binary file not shown
BIN ?????  lib/IOShieldOled/IOShield Library - Oeld.pdf View file @ 5a843cc
Binary file not shown
740 ????? lib/IOShieldOled/IOShieldOled.cpp View file @ 5a843cc
...	...	 @@ -0,0 +1,740 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  IOShieldOled.c  --  OLED Display Driver for Basic I/O Shield    */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:   Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  Module Description:                         */
 	26	 +/*                                    */
 	27	 +/*  This module contains the implementation of the object class that  */
 	28	 +/*  forms the chipKIT interface to the graphics driver functions for  */
 	29	 +/*  the OLED display on the Digilent Basic I/O Shield.          */
 	30	 +/*                                    */
 	31	 +/************************************************************************/
 	32	 +/*  Revision History:                          */
 	33	 +/*                                    */
 	34	 +/*  06/01/2011(GeneA): created                      */
 	35	 +/*  08/04/2011(GeneA): prepare first release              */
 	36	 +/*  01/04/2012(GeneA): removed delay.h                  */
 	37	 +/*                                    */
 	38	 +/************************************************************************/
 	39	 +
 	40	 +
 	41	 +/* ------------------------------------------------------------ */
 	42	 +/*        Include File Definitions            */
 	43	 +/* ------------------------------------------------------------ */
 	44	 +
 	45	 +#include "IOShieldOled.h"
 	46	 +
 	47	 +extern "C" {
 	48	 +  #include <stdlib.h>
 	49	 +  #include <string.h>
 	50	 +  #include <inttypes.h>
 	51	 +  #include "OledDriver.h"
 	52	 +  #include "OledChar.h"
 	53	 +  #include "OledGrph.h"
 	54	 +}
 	55	 +
 	56	 +/* ------------------------------------------------------------ */
 	57	 +/*        Local Type Definitions              */
 	58	 +/* ------------------------------------------------------------ */
 	59	 +
 	60	 +
 	61	 +/* ------------------------------------------------------------ */
 	62	 +/*      OLED Driver Object Instantiation          */
 	63	 +/* ------------------------------------------------------------ */
 	64	 +/* Instantiate a single static instance of this object class
 	65	 +*/
 	66	 +
 	67	 +IOShieldOledClass IOShieldOled = IOShieldOledClass();
 	68	 +
 	69	 +/* ------------------------------------------------------------ */
 	70	 +/*        IOShieldOledClass Definitions          */
 	71	 +/* ------------------------------------------------------------ */
 	72	 +
 	73	 +/* ------------------------------------------------------------ */
 	74	 +/***  void IOShieldOledClass::IOShieldOledClass()
 	75	 +**
 	76	 +**  Parameters:
 	77	 +**    none
 	78	 +**
 	79	 +**  Return Value:
 	80	 +**    none
 	81	 +**
 	82	 +**  Errors:
 	83	 +**    none
 	84	 +**
 	85	 +**  Description:
 	86	 +**    Default constructor.
 	87	 +*/
 	88	 +
 	89	 +IOShieldOledClass::IOShieldOledClass()
 	90	 +{
 	91	 +}
 	92	 +
 	93	 +/* ------------------------------------------------------------ */
 	94	 +/***  void IOShieldOledClass::begin(void)
 	95	 +**
 	96	 +**  Parameters:
 	97	 +**    none
 	98	 +**
 	99	 +**  Return Value:
 	100	 +**    none
 	101	 +**
 	102	 +**  Errors:
 	103	 +**    none
 	104	 +**
 	105	 +**  Description:
 	106	 +**    Initialize the OLED display controller and turn the display on.
 	107	 +*/
 	108	 +void IOShieldOledClass::begin(void)
 	109	 +{
 	110	 +  OledInit();
 	111	 +}
 	112	 +
 	113	 +/* ------------------------------------------------------------ */
 	114	 +/***  void IOShieldOledClass::end(void)
 	115	 +**
 	116	 +**  Parameters:
 	117	 +**    none
 	118	 +**
 	119	 +**  Return Value:
 	120	 +**    none
 	121	 +**
 	122	 +**  Errors:
 	123	 +**    none
 	124	 +**
 	125	 +**  Description:
 	126	 +**    Shut down the OLED display. This turns the power off to the
 	127	 +**    OLED display, and releases all of the PIC32 resources used
 	128	 +**    by the OLED display driver.
 	129	 +*/
 	130	 +
 	131	 +void IOShieldOledClass::end()
 	132	 +{
 	133	 +  OledTerm();
 	134	 +}
 	135	 +
 	136	 +/* ------------------------------------------------------------ */
 	137	 +/***  void IOShieldOledClass::displayOn(void)
 	138	 +**
 	139	 +**  Parameters:
 	140	 +**    none
 	141	 +**
 	142	 +**  Return Value:
 	143	 +**    none
 	144	 +**
 	145	 +**  Errors:
 	146	 +**    none
 	147	 +**
 	148	 +**  Description:
 	149	 +**    Turn the display on. This assumes that the display has been
 	150	 +**    initialized and is powered on. It just unblanks the display.
 	151	 +*/
 	152	 +
 	153	 +void IOShieldOledClass::displayOn()
 	154	 +{
 	155	 +  OledDisplayOn();
 	156	 +}
 	157	 +
 	158	 +/* ------------------------------------------------------------ */
 	159	 +/***  void IOShieldOledClass::displayOff(void)
 	160	 +**
 	161	 +**  Parameters:
 	162	 +**    none
 	163	 +**
 	164	 +**  Return Value:
 	165	 +**    none
 	166	 +**
 	167	 +**  Errors:
 	168	 +**    none
 	169	 +**
 	170	 +**  Description:
 	171	 +**    Turn the display off. This doesn't power the display down.
 	172	 +**    It blanks the display, but does not clear it.
 	173	 +*/
 	174	 +
 	175	 +void IOShieldOledClass::displayOff()
 	176	 +{
 	177	 +  OledDisplayOff();
 	178	 +}
 	179	 +
 	180	 +/* ------------------------------------------------------------ */
 	181	 +/***  void IOShieldOledClass::clear(void)
 	182	 +**
 	183	 +**  Parameters:
 	184	 +**    none
 	185	 +**
 	186	 +**  Return Value:
 	187	 +**    none
 	188	 +**
 	189	 +**  Errors:
 	190	 +**    none
 	191	 +**
 	192	 +**  Description:
 	193	 +**    Clear the display. This clears the memory buffer and then
 	194	 +**    updates the display.
 	195	 +*/
 	196	 +void IOShieldOledClass::clear(void)
 	197	 +{
 	198	 +  OledClear();
 	199	 +}
 	200	 +
 	201	 +/* ------------------------------------------------------------ */
 	202	 +/***  void IOShieldOledClass::clearBuffer(void)
 	203	 +**
 	204	 +**  Parameters:
 	205	 +**    none
 	206	 +**
 	207	 +**  Return Value:
 	208	 +**    none
 	209	 +**
 	210	 +**  Errors:
 	211	 +**    none
 	212	 +**
 	213	 +**  Description:
 	214	 +**    Clear the display memory buffer.
 	215	 +*/
 	216	 +void IOShieldOledClass::clearBuffer(void)
 	217	 +{
 	218	 +  OledClearBuffer();
 	219	 +}
 	220	 +
 	221	 +/* ------------------------------------------------------------ */
 	222	 +/***  void IOShieldOledClass::updateDisplay(void)
 	223	 +**
 	224	 +**  Parameters:
 	225	 +**    none
 	226	 +**
 	227	 +**  Return Value:
 	228	 +**    none
 	229	 +**
 	230	 +**  Errors:
 	231	 +**    none
 	232	 +**
 	233	 +**  Description:
 	234	 +**    Update the OLED display with the contents of the memory buffer
 	235	 +*/
 	236	 +void IOShieldOledClass::updateDisplay(void)
 	237	 +{
 	238	 +  OledUpdate();
 	239	 +}
 	240	 +
 	241	 +/* ------------------------------------------------------------ */
 	242	 +/***  void IOShieldOledClass::setCursor(int xch, int ych);
 	243	 +**
 	244	 +**  Parameters:
 	245	 +**    xch      - horizontal character position
 	246	 +**    ych      - vertical character position
 	247	 +**
 	248	 +**  Return Value:
 	249	 +**    none
 	250	 +**
 	251	 +**  Errors:
 	252	 +**    none
 	253	 +**
 	254	 +**  Description:
 	255	 +**    Set the character cursor position to the specified location.
 	256	 +**    If either the specified X or Y location is off the display, it
 	257	 +**    is clamped to be on the display.
 	258	 +*/
 	259	 +void IOShieldOledClass::setCursor(int xch, int ych)
 	260	 +{
 	261	 +  OledSetCursor(xch,ych);
 	262	 +}
 	263	 +
 	264	 +/* ------------------------------------------------------------ */
 	265	 +/***  void IOShieldOledClass::getCursor(int * pxcy, int * pych)
 	266	 +**
 	267	 +**  Parameters:
 	268	 +**    pxch    - pointer to variable to receive horizontal position
 	269	 +**    pych    - pointer to variable to receive vertical position
 	270	 +**
 	271	 +**  Return Value:
 	272	 +**    none
 	273	 +**
 	274	 +**  Errors:
 	275	 +**    none
 	276	 +**
 	277	 +**  Description:
 	278	 +**    Fetch the current cursor position
 	279	 +*/
 	280	 +void IOShieldOledClass::getCursor(int * pxch, int * pych)
 	281	 +{
 	282	 +  OledGetCursor(pxch, pych);
 	283	 +}
 	284	 +
 	285	 +/* ------------------------------------------------------------ */
 	286	 +/***  int IOShieldOledClass::defineUserChar(char ch, uint8_t * pbDef)
 	287	 +**
 	288	 +**  Parameters:
 	289	 +**    ch    - character code to define
 	290	 +**    pbDef  - definition for the character
 	291	 +**
 	292	 +**  Return Value:
 	293	 +**    none
 	294	 +**
 	295	 +**  Errors:
 	296	 +**    Returns TRUE if successful, FALSE if not
 	297	 +**
 	298	 +**  Description:
 	299	 +**    Give a definition for the glyph for the specified user
 	300	 +**    character code. User definable character codes are in
 	301	 +**    the range 0x00 - 0x1F. If the code specified by ch is
 	302	 +**    outside this range, the function returns false.
 	303	 +*/
 	304	 +int IOShieldOledClass::defineUserChar(char ch, uint8_t * pbDef)
 	305	 +{
 	306	 +  return OledDefUserChar(ch, pbDef);
 	307	 +}
 	308	 +
 	309	 +/* ------------------------------------------------------------ */
 	310	 +/***  void IOShieldOledClass::setCharUpdate(int f)
 	311	 +**
 	312	 +**  Parameters:
 	313	 +**    f    - enable/disable automatic update
 	314	 +**
 	315	 +**  Return Value:
 	316	 +**    none
 	317	 +**
 	318	 +**  Errors:
 	319	 +**    none
 	320	 +**
 	321	 +**  Description:
 	322	 +**    Set the character update mode. This determines whether
 	323	 +**    or not the display is automatically updated after a
 	324	 +**    character or string is drawn. A non-zero value turns
 	325	 +**    automatic updating on.
 	326	 +*/
 	327	 +void IOShieldOledClass::setCharUpdate(int f)
 	328	 +{
 	329	 +  OledSetCharUpdate(f);
 	330	 +}
 	331	 +
 	332	 +/* ------------------------------------------------------------ */
 	333	 +/***  int IOShieldOledClass::getCharUpdate(void)
 	334	 +**
 	335	 +**  Parameters:
 	336	 +**    none
 	337	 +**
 	338	 +**  Return Value:
 	339	 +**    returns current character update mode
 	340	 +**
 	341	 +**  Errors:
 	342	 +**    none
 	343	 +**
 	344	 +**  Description:
 	345	 +**    Return the current character update mode.
 	346	 +*/
 	347	 +int IOShieldOledClass::getCharUpdate(void)
 	348	 +{
 	349	 +  return OledGetCharUpdate();
 	350	 +}
 	351	 +
 	352	 +/* ------------------------------------------------------------ */
 	353	 +/***  void IOShieldOledClass::putChar(char ch)
 	354	 +**
 	355	 +**  Parameters:
 	356	 +**    ch      - character to write to display
 	357	 +**
 	358	 +**  Return Value:
 	359	 +**    none
 	360	 +**
 	361	 +**  Errors:
 	362	 +**    none
 	363	 +**
 	364	 +**  Description:
 	365	 +**    Write the specified character to the display at the current
 	366	 +**    cursor position and advance the cursor.
 	367	 +*/
 	368	 +void IOShieldOledClass::putChar(char ch)
 	369	 +{
 	370	 +  OledPutChar(ch);
 	371	 +}
 	372	 +
 	373	 +/* ------------------------------------------------------------ */
 	374	 +/***  void IOShieldOledClass::putString(char * sz)
 	375	 +**
 	376	 +**  Parameters:
 	377	 +**    sz    - pointer to the null terminated string
 	378	 +**
 	379	 +**  Return Value:
 	380	 +**    none
 	381	 +**
 	382	 +**  Errors:
 	383	 +**    none
 	384	 +**
 	385	 +**  Description:
 	386	 +**    Write the specified null terminated character string to the
 	387	 +**    display and advance the cursor.
 	388	 +*/
 	389	 +void IOShieldOledClass::putString(char * sz)
 	390	 +{
 	391	 +  OledPutString(sz);
 	392	 +}
 	393	 +
 	394	 +/* ------------------------------------------------------------ */
 	395	 +/***  void IOShieldOledClass::setDrawColor(uint8_t clr)
 	396	 +**
 	397	 +**  Parameters:
 	398	 +**    clr    - drawing color to set
 	399	 +**
 	400	 +**  Return Value:
 	401	 +**    none
 	402	 +**
 	403	 +**  Errors:
 	404	 +**    none
 	405	 +**
 	406	 +**  Description:
 	407	 +**    Set the foreground color used for pixel draw operations.
 	408	 +*/
 	409	 +void IOShieldOledClass::setDrawColor(uint8_t clr)
 	410	 +{
 	411	 +  OledSetDrawColor(clr);
 	412	 +}
 	413	 +
 	414	 +/* ------------------------------------------------------------ */
 	415	 +/***  void IOShieldOledClass::setDrawMode(int mod);
 	416	 +**
 	417	 +**  Parameters:
 	418	 +**    mod    - drawing mode to select
 	419	 +**
 	420	 +**  Return Value:
 	421	 +**    none
 	422	 +**
 	423	 +**  Errors:
 	424	 +**    none
 	425	 +**
 	426	 +**  Description:
 	427	 +**    Set the specified mode as the current drawing mode.
 	428	 +*/
 	429	 +void IOShieldOledClass::setDrawMode(int mod)
 	430	 +{
 	431	 +  OledSetDrawMode(mod);
 	432	 +}
 	433	 +
 	434	 +/* ------------------------------------------------------------ */
 	435	 +/***  int IOShieldOledClass::getDrawMode();
 	436	 +**
 	437	 +**  Parameters:
 	438	 +**    none
 	439	 +
 	440	 +**  Return Value:
 	441	 +**    returns current drawing mode
 	442	 +**
 	443	 +**  Errors:
 	444	 +**    none
 	445	 +**
 	446	 +**  Description:
 	447	 +**    Get the current drawing mode
 	448	 +*/
 	449	 +int IOShieldOledClass::getDrawMode(void)
 	450	 +{
 	451	 +  return OledGetDrawMode();
 	452	 +}
 	453	 +
 	454	 +/* ------------------------------------------------------------ */
 	455	 +/***  uint8_t * IOShieldOledClass::getStdPattern(int ipat)
 	456	 +**
 	457	 +**  Parameters:
 	458	 +**    ipat    - index to standard fill pattern
 	459	 +**
 	460	 +**  Return Value:
 	461	 +**    returns a pointer to the standard fill pattern
 	462	 +**
 	463	 +**  Errors:
 	464	 +**    returns pattern 0 if index out of range
 	465	 +**
 	466	 +**  Description:
 	467	 +**    Return a pointer to the byte array for the specified
 	468	 +**    standard fill pattern.
 	469	 +*/
 	470	 +uint8_t * IOShieldOledClass::getStdPattern(int ipat)
 	471	 +{
 	472	 +  return OledGetStdPattern(ipat);
 	473	 +}
 	474	 +
 	475	 +/* ------------------------------------------------------------ */
 	476	 +/***  void IOShieldOledClass::setFillPattern(uint8_t * pbPat)
 	477	 +**
 	478	 +**  Parameters:
 	479	 +**    pbPat  - pointer to the fill pattern
 	480	 +**
 	481	 +**  Return Value:
 	482	 +**    none
 	483	 +**
 	484	 +**  Errors:
 	485	 +**    none
 	486	 +**
 	487	 +**  Description:
 	488	 +**    Set a pointer to the current fill pattern to use. A fill
 	489	 +**    pattern is an array of 8 bytes.
 	490	 +*/
 	491	 +void IOShieldOledClass::setFillPattern(uint8_t * pbPat)
 	492	 +{
 	493	 +  OledSetFillPattern(pbPat);
 	494	 +}
 	495	 +
 	496	 +/* ------------------------------------------------------------ */
 	497	 +/***  void IOShieldOledClass::moveTo(int xco, int yco)
 	498	 +**
 	499	 +**  Parameters:
 	500	 +**    xco      - x coordinate
 	501	 +**    yco      - y coordinate
 	502	 +**
 	503	 +**  Return Value:
 	504	 +**    none
 	505	 +**
 	506	 +**  Errors:
 	507	 +**    none
 	508	 +**
 	509	 +**  Description:
 	510	 +**    Set the current graphics drawing position.
 	511	 +*/
 	512	 +
 	513	 +void IOShieldOledClass::moveTo(int xco, int yco)
 	514	 +{
 	515	 +  OledMoveTo(xco, yco);
 	516	 +}
 	517	 +
 	518	 +/* ------------------------------------------------------------ */
 	519	 +/***  void IOShieldOledClass::getPos(int * pxco, int * pyco)
 	520	 +**
 	521	 +**  Parameters:
 	522	 +**    pxco  - variable to receive x coordinate
 	523	 +**    pyco  - variable to receive y coordinate
 	524	 +**
 	525	 +**  Return Value:
 	526	 +**    none
 	527	 +**
 	528	 +**  Errors:
 	529	 +**    none
 	530	 +**
 	531	 +**  Description:
 	532	 +**    Fetch the current graphics drawing position
 	533	 +*/
 	534	 +void IOShieldOledClass::getPos(int * pxco, int * pyco)
 	535	 +{
 	536	 +  OledGetPos(pxco, pyco);
 	537	 +}
 	538	 +
 	539	 +/* ------------------------------------------------------------ */
 	540	 +/***  void IOShieldOledClass::drawPixel(void)
 	541	 +**
 	542	 +**  Parameters:
 	543	 +**    none
 	544	 +**
 	545	 +**  Return Value:
 	546	 +**    none
 	547	 +**
 	548	 +**  Errors:
 	549	 +**    none
 	550	 +**
 	551	 +**  Description:
 	552	 +**    Set the pixel at the current drawing location to the
 	553	 +**    specified value.
 	554	 +*/
 	555	 +void IOShieldOledClass::drawPixel(void)
 	556	 +{
 	557	 +  OledDrawPixel();
 	558	 +}
 	559	 +
 	560	 +/* ------------------------------------------------------------ */
 	561	 +/***  uint8_t IOShieldOledClass::getPixel(void)
 	562	 +**
 	563	 +**  Parameters:
 	564	 +**    none
 	565	 +**
 	566	 +**  Return Value:
 	567	 +**    returns pixel value at current drawing location
 	568	 +**
 	569	 +**  Errors:
 	570	 +**    none
 	571	 +**
 	572	 +**  Description:
 	573	 +**    Return the value of the pixel at the current drawing location
 	574	 +*/
 	575	 +uint8_t IOShieldOledClass::getPixel(void)
 	576	 +{
 	577	 +  return OledGetPixel();
 	578	 +}
 	579	 +
 	580	 +/* ------------------------------------------------------------ */
 	581	 +/***  void IOShieldOledClass::drawLine(int xco, int yco)
 	582	 +**
 	583	 +**  Parameters:
 	584	 +**    xco      - x coordinate
 	585	 +**    yco      - y coordinate
 	586	 +**
 	587	 +**  Return Value:
 	588	 +**    none
 	589	 +**
 	590	 +**  Errors:
 	591	 +**    none
 	592	 +**
 	593	 +**  Description:
 	594	 +**    Draw a line from the current position to the specified
 	595	 +**    position.
 	596	 +*/
 	597	 +void IOShieldOledClass::drawLine(int xco, int yco)
 	598	 +{
 	599	 +  OledLineTo(xco, yco);
 	600	 +}
 	601	 +
 	602	 +/* ------------------------------------------------------------ */
 	603	 +/***  void IOShieldOledClass::drawRect(int xco, int yco)
 	604	 +**
 	605	 +**  Parameters:
 	606	 +**    xco    - x coordinate of other corner
 	607	 +**    yco    - y coordinate of other corner
 	608	 +**
 	609	 +**  Return Value:
 	610	 +**    none
 	611	 +**
 	612	 +**  Errors:
 	613	 +**    none
 	614	 +**
 	615	 +**  Description:
 	616	 +**    Draw a rectangle bounded by the current location and
 	617	 +**    the specified location.
 	618	 +*/
 	619	 +void IOShieldOledClass::drawRect(int xco, int yco)
 	620	 +{
 	621	 +  OledDrawRect(xco, yco);
 	622	 +}
 	623	 +
 	624	 +/* ------------------------------------------------------------ */
 	625	 +/***  void IOShieldOledClass::drawFillRect(int xco, int yco)
 	626	 +**
 	627	 +**  Parameters:
 	628	 +**    xco    - x coordinate of other corner
 	629	 +**    yco    - y coordinate of other corner
 	630	 +**
 	631	 +**  Return Value:
 	632	 +**    none
 	633	 +**
 	634	 +**  Errors:
 	635	 +**    none
 	636	 +**
 	637	 +**  Description:
 	638	 +**    Fill a rectangle bounded by the current location and
 	639	 +**    the specified location.
 	640	 +*/
 	641	 +void IOShieldOledClass::drawFillRect(int xco, int yco)
 	642	 +{
 	643	 +  OledFillRect(xco, yco);
 	644	 +}
 	645	 +
 	646	 +/* ------------------------------------------------------------ */
 	647	 +/***  void IOShieldOledClass::getBmp(int dxco, int dyco, uint8_t * pbBmp)
 	648	 +**
 	649	 +**  Parameters:
 	650	 +**    dxco    - width of bitmap
 	651	 +**    dyco    - height of bitmap
 	652	 +**    pbBits    - pointer to the bitmap bits  
 	653	 +**
 	654	 +**  Return Value:
 	655	 +**    none
 	656	 +**
 	657	 +**  Errors:
 	658	 +**    none
 	659	 +**
 	660	 +**  Description:
 	661	 +**    This routine will get the bits corresponding to the
 	662	 +**    rectangle implied by the current location and the
 	663	 +**    specified width and height. The buffer specified
 	664	 +**    by pbBits must be large enough to hold the resulting
 	665	 +**    bytes.
 	666	 +*/
 	667	 +void IOShieldOledClass::getBmp(int dxco, int dyco, uint8_t * pbBmp)
 	668	 +{
 	669	 +  OledGetBmp(dxco, dyco, pbBmp);
 	670	 +}
 	671	 +
 	672	 +/* ------------------------------------------------------------ */
 	673	 +/***  void IOShieldOledClass::putBmp(int dxcp, int dyco, uint8_t * pbBmp)
 	674	 +**
 	675	 +**  Parameters:
 	676	 +**    dxco    - width of bitmap
 	677	 +**    dyco    - height of bitmap
 	678	 +**    pbBits    - pointer to the bitmap bits  
 	679	 +**
 	680	 +**  Return Value:
 	681	 +**    none
 	682	 +**
 	683	 +**  Errors:
 	684	 +**    none
 	685	 +**
 	686	 +**  Description:
 	687	 +**    This routine will put the specified bitmap into the display
 	688	 +**    buffer at the current location.
 	689	 +*/
 	690	 +void IOShieldOledClass::putBmp(int dxcp, int dyco, uint8_t * pbBmp)
 	691	 +{
 	692	 +  OledPutBmp(dxcp, dyco, pbBmp);
 	693	 +}
 	694	 +
 	695	 +/* ------------------------------------------------------------ */
 	696	 +/***  void IOShieldOledClass::drawChar(char ch)
 	697	 +**
 	698	 +**  Parameters:
 	699	 +**    ch      - character to write to display
 	700	 +**
 	701	 +**  Return Value:
 	702	 +**    none
 	703	 +**
 	704	 +**  Errors:
 	705	 +**    none
 	706	 +**
 	707	 +**  Description:
 	708	 +**    Write the specified character to the display at the current
 	709	 +**    cursor position and advance the cursor.
 	710	 +*/
 	711	 +void IOShieldOledClass::drawChar(char ch)
 	712	 +{
 	713	 +  OledDrawChar(ch);
 	714	 +}
 	715	 +
 	716	 +/* ------------------------------------------------------------ */
 	717	 +/***  void IOShieldOledClass::drawString(char * sz)
 	718	 +**
 	719	 +**  Parameters:
 	720	 +**    sz    - pointer to the null terminated string
 	721	 +**
 	722	 +**  Return Value:
 	723	 +**    none
 	724	 +**
 	725	 +**  Errors:
 	726	 +**    none
 	727	 +**
 	728	 +**  Description:
 	729	 +**    Write the specified null terminated character string to the
 	730	 +**    display and advance the cursor.
 	731	 +*/
 	732	 +void IOShieldOledClass::drawString(char * sz)
 	733	 +{
 	734	 +  OledDrawString(sz);
 	735	 +}
 	736	 +
 	737	 +/* ------------------------------------------------------------ */
 	738	 +
 	739	 +/************************************************************************/
 	740	 +
123 ????? lib/IOShieldOled/IOShieldOled.h View file @ 5a843cc
...	...	 @@ -0,0 +1,123 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  IOShieldOled.h  --  Interface Declarations for IOShieldOled.cpp    */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:    Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  File Description:                          */
 	26	 +/*                                    */
 	27	 +/*  This header file contains the object class declarations and other  */
 	28	 +/*  interface declarations need to use the OLED graphics display driver  */
 	29	 +/*  for the Digilent Basic I/O Shield.                  */
 	30	 +/*                                    */
 	31	 +/************************************************************************/
 	32	 +/*  Revision History:                          */
 	33	 +/*                                    */
 	34	 +/*  04/29/2011(OliverJ): created                    */
 	35	 +/*  08/03/2011(GeneA): added new functions for display control      */
 	36	 +/*  08/04/2011(GeneA): prepare first release              */
 	37	 +/*                                    */
 	38	 +/************************************************************************/
 	39	 +
 	40	 +#if !defined(IOSHIELDOLED_H)
 	41	 +#define IOSHIELDOLED_H
 	42	 +
 	43	 +/* ------------------------------------------------------------ */
 	44	 +/*          Miscellaneous Declarations          */
 	45	 +/* ------------------------------------------------------------ */
 	46	 +
 	47	 +#include <inttypes.h>
 	48	 +
 	49	 +/* ------------------------------------------------------------ */
 	50	 +/*          Global Variable Declarations        */
 	51	 +/* ------------------------------------------------------------ */
 	52	 +
 	53	 +class IOShieldOledClass;
 	54	 +extern IOShieldOledClass IOShieldOled;
 	55	 +
 	56	 +/* ------------------------------------------------------------ */
 	57	 +/*          Object Class Declarations          */
 	58	 +/* ------------------------------------------------------------ */
 	59	 +
 	60	 +class IOShieldOledClass
 	61	 +{
 	62	 +  private:
 	63	 +     
 	64	 +  public:
 	65	 +    /* Class Constants
 	66	 +  */
 	67	 +  static const int colMax = 128;  //number of columns in the display
 	68	 +  static const int rowMax = 32;  //number of rows in the display
 	69	 +  static const int pageMax = 4;  //number of display pages
 	70	 +
 	71	 +  static const int modeSet = 0;  //set pixel drawing mode
 	72	 +  static const int modeOr  = 1;  //or pixels drawing mode
 	73	 +  static const int modeAnd = 2;  //and pixels drawing mode
 	74	 +  static const int modeXor = 3;  //xor pixels drawing mode
 	75	 +
 	76	 +    IOShieldOledClass();
 	77	 +
 	78	 +  /* Basic device control functions.
 	79	 +  */
 	80	 +    void    begin(void);
 	81	 +  void    end(void);
 	82	 +  void    displayOn(void);
 	83	 +  void    displayOff(void);
 	84	 +  void    clear(void);
 	85	 +  void    clearBuffer(void);
 	86	 +  void    updateDisplay(void);
 	87	 +
 	88	 +  /* Character output functions.
 	89	 +  */
 	90	 +  void    setCursor(int xch, int ych);
 	91	 +  void    getCursor(int * pxch, int * pych);
 	92	 +  int      defineUserChar(char ch, uint8_t * pbDef);
 	93	 +  void    setCharUpdate(int f);
 	94	 +  int      getCharUpdate(void);
 	95	 +  void    putChar(char ch);
 	96	 +  void    putString(char * sz);
 	97	 +
 	98	 +  /* Graphic output functions.
 	99	 +  */
 	100	 +  void    setDrawColor(uint8_t clr);
 	101	 +  void    setDrawMode(int mod);
 	102	 +  int      getDrawMode();
 	103	 +  uint8_t *  getStdPattern(int ipat);
 	104	 +  void    setFillPattern(uint8_t * pbPat);
 	105	 +
 	106	 +  void    moveTo(int xco, int yco);
 	107	 +  void    getPos(int * pxco, int * pyco);
 	108	 +  void    drawPixel(void);
 	109	 +  uint8_t    getPixel(void);
 	110	 +  void    drawLine(int xco, int yco);
 	111	 +  void    drawRect(int xco, int yco);
 	112	 +  void    drawFillRect(int xco, int yco);
 	113	 +  void    getBmp(int dxco, int dyco, uint8_t * pbBmp);
 	114	 +  void    putBmp(int dxcp, int dyco, uint8_t * pbBmp);
 	115	 +  void    drawChar(char ch);
 	116	 +  void    drawString(char *sz);
 	117	 +};
 	118	 +
 	119	 +/* ------------------------------------------------------------ */
 	120	 +
 	121	 +#endif
 	122	 +
 	123	 +/************************************************************************/
133 ????? lib/IOShieldOled/examples/IOShield_Oled_Demo/IOShield_Oled_Demo.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,133 @@
 	1	 +
 	2	 +/************************************************************************/
 	3	 +/*                  */
 	4	 +/*  IOShieldOled.c  --  OLED Display Driver for Basic I/O Shield        */
 	5	 +/*                  */
 	6	 +/************************************************************************/
 	7	 +/*  Author:   Oliver Jones            */
 	8	 +/*  Copyright 2011, Digilent Inc.          */
 	9	 +/************************************************************************/
 	10	 +/*
 	11	 +  This program is free software; you can redistribute it and/or
 	12	 +  modify it under the terms of the GNU Lesser General Public
 	13	 +  License as published by the Free Software Foundation; either
 	14	 +  version 2.1 of the License, or (at your option) any later version.
 	15	 +
 	16	 +  This library is distributed in the hope that it will be useful,
 	17	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	18	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	19	 +  Lesser General Public License for more details.
 	20	 +
 	21	 +  You should have received a copy of the GNU Lesser General Public
 	22	 +  License along with this library; if not, write to the Free Software
 	23	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	24	 +*/
 	25	 +/************************************************************************/
 	26	 +/*  Module Description:             */
 	27	 +/*                  */
 	28	 +/*  This program demonstrates the basic operation of the OLED graphics  */
 	29	 +/*  display on the Digilent Basic I/O Shield. It illustrates the        */
 	30	 +/*  initialization of the display and some basic character and graphic  */
 	31	 +/*  operations.                                                         */
 	32	 +/*                  */
 	33	 +/************************************************************************/
 	34	 +/*  Revision History:              */
 	35	 +/*                  */
 	36	 +/*  06/01/2011(GeneA): created            */
 	37	 +/*  08/04/2011(GeneA): prepare first release        */
 	38	 +/*                  */
 	39	 +/************************************************************************/
 	40	 +
 	41	 +#include <IOShieldOled.h>
 	42	 +
 	43	 +void setup()
 	44	 +{
 	45	 +  IOShieldOled.begin();
 	46	 +}
 	47	 +
 	48	 +void loop()
 	49	 +{
 	50	 +  int irow;
 	51	 +  int ib;
 	52	 +
 	53	 +  //Clear the virtual buffer
 	54	 +  IOShieldOled.clearBuffer();
 	55	 +  
 	56	 +  //Chosing Fill pattern 0
 	57	 +  IOShieldOled.setFillPattern(IOShieldOled.getStdPattern(0));
 	58	 +  //Turn automatic updating off
 	59	 +  IOShieldOled.setCharUpdate(0);
 	60	 +  
 	61	 +  //Draw a rectangle over wrting then slide the rectagle
 	62	 +  //down slowly displaying all writing
 	63	 +  for (irow = 0; irow < IOShieldOled.rowMax; irow++)
 	64	 +  {
 	65	 +    IOShieldOled.clearBuffer();
 	66	 +    IOShieldOled.setCursor(0, 0);
 	67	 +    IOShieldOled.putString("chipKIT");
 	68	 +    IOShieldOled.setCursor(0, 1);
 	69	 +    IOShieldOled.putString("Basic I/O Shield");
 	70	 +    IOShieldOled.setCursor(0, 2);
 	71	 +    IOShieldOled.putString("by Digilent");
 	72	 +    
 	73	 +    IOShieldOled.moveTo(0, irow);
 	74	 +    IOShieldOled.drawFillRect(127,31);
 	75	 +    IOShieldOled.moveTo(0, irow);
 	76	 +    IOShieldOled.drawLine(127,irow);
 	77	 +    IOShieldOled.updateDisplay();
 	78	 +    delay(100);
 	79	 +  }
 	80	 +  
 	81	 +  delay(1000);
 	82	 +  
 	83	 +  // Blink the display a bit.
 	84	 +  IOShieldOled.displayOff();
 	85	 +  delay(500);
 	86	 +  IOShieldOled.displayOn();
 	87	 +  delay(500);
 	88	 +  
 	89	 +  IOShieldOled.displayOff();
 	90	 +  delay(500);
 	91	 +  IOShieldOled.displayOn();
 	92	 +  delay(500);
 	93	 +
 	94	 +  IOShieldOled.displayOff();
 	95	 +  delay(500);
 	96	 +  IOShieldOled.displayOn();
 	97	 +  delay(500);
 	98	 +
 	99	 +  delay(2000);
 	100	 +  
 	101	 +  // Now erase the characters from the display
 	102	 +  for (irow = IOShieldOled.rowMax-1; irow >= 0; irow--) {
 	103	 +    IOShieldOled.setDrawColor(1);
 	104	 +    IOShieldOled.setDrawMode(IOShieldOled.modeSet);
 	105	 +    IOShieldOled.moveTo(0,irow);
 	106	 +    IOShieldOled.drawLine(127,irow);
 	107	 +    IOShieldOled.updateDisplay();
 	108	 +    delay(25);
 	109	 +    IOShieldOled.setDrawMode(IOShieldOled.modeXor);
 	110	 +    IOShieldOled.moveTo(0, irow);
 	111	 +    IOShieldOled.drawLine(127, irow);
 	112	 +    IOShieldOled.updateDisplay();
 	113	 +  }
 	114	 +  
 	115	 +  delay(1000);  
 	116	 +
 	117	 +  // Draw a rectangle in center of screen
 	118	 +  // Display the 8 different patterns availible
 	119	 +  IOShieldOled.setDrawMode(IOShieldOled.modeSet);
 	120	 +
 	121	 +  for(ib = 1; ib < 8; ib++)
 	122	 +  {
 	123	 +    IOShieldOled.clearBuffer();
 	124	 +    
 	125	 +    IOShieldOled.setFillPattern(IOShieldOled.getStdPattern(ib));
 	126	 +    IOShieldOled.moveTo(55, 1);
 	127	 +    IOShieldOled.drawFillRect(75, 27);
 	128	 +    IOShieldOled.drawRect(75, 27);
 	129	 +    IOShieldOled.updateDisplay();
 	130	 +    
 	131	 +    delay(1000);
 	132	 +  }
 	133	 +}
BIN ?????  lib/IOShieldOled/examples/OLED_Full_Demo.zip View file @ 5a843cc
Binary file not shown
1,064 ????? lib/IOShieldOled/examples/Oled_Full_Demo/Oled_Full_Demo.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,1064 @@
 	1	 +/************************************************************************/
 	2	 +/*                  */
 	3	 +/*  OledDemo.pde -- Example OLED Sketch for chipKIT Basic I/O Shield  */
 	4	 +/*                  */
 	5	 +/************************************************************************/
 	6	 +/*  Author:  Gene Apperson            */
 	7	 +/*  Copyright (c) 2011, Digilent Inc.                      */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This program is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This program is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  Module Description:              */
 	26	 +/*                  */
 	27	 +/*  The sketch is an example program demonstrating the use of many of   */
 	28	 +/*  of the library functions used to access the OLED display on the     */
 	29	 +/*  Digilent chipKIT Basic I/O Shield.                                  */
 	30	 +/*                  */
 	31	 +/************************************************************************/
 	32	 +/*  Revision History:              */
 	33	 +/*                  */
 	34	 +/*  08/24/2011(GeneApperson): Created                                   */
 	35	 +/*                  */
 	36	 +/************************************************************************/
 	37	 +
 	38	 +
 	39	 +/* ------------------------------------------------------------ */
 	40	 +/*    Include File Definitions      */
 	41	 +/* ------------------------------------------------------------ */
 	42	 +
 	43	 +#include <IOShieldOled.h>
 	44	 +
 	45	 +#include <Wprogram.h>
 	46	 +
 	47	 +/* ------------------------------------------------------------ */
 	48	 +/*    Local Type and Constant Definitions    */
 	49	 +/* ------------------------------------------------------------ */
 	50	 +
 	51	 +#define  OLED  IOShieldOledClass
 	52	 +
 	53	 +#define cbOledChar      8                //number of bytes in a glyph
 	54	 +#define cbOledFontUser  (32*cbOledChar)  //number of bytes in user font table
 	55	 +
 	56	 +/* ------------------------------------------------------------ */
 	57	 +/*    Global Variables        */
 	58	 +/* ------------------------------------------------------------ */
 	59	 +
 	60	 +OLED  oled;
 	61	 +
 	62	 +/* ------------------------------------------------------------ */
 	63	 +/*    Local Variables          */
 	64	 +/* ------------------------------------------------------------ */
 	65	 +
 	66	 +/* Bitmap used by the putBmp function demonstration.
 	67	 +*/
 	68	 +uint8_t rgbBmp0[] = {
 	69	 +  0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
 	70	 +  0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18
 	71	 +};
 	72	 +
 	73	 +/* Buffer to hold bitmap copied from the display in the getBmp
 	74	 +** demonstration.
 	75	 +*/
 	76	 +uint8_t rgbBmp1[32];
 	77	 +
 	78	 +/* Array containing a user defined font table. There can be up
 	79	 +** to 32 user defined characters. This table only defines 24
 	80	 +** of them.
 	81	 +** Each 8-byte row below defines one character glyph.
 	82	 +*/
 	83	 +uint8_t rgbUserFont[cbOledFontUser] = {
 	84	 +  0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7E,  // 0x00
 	85	 +  0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,  // 0x01
 	86	 +  0x7E, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  // 0x02
 	87	 +  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E,  // 0x03
 	88	 +  0x7E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x04
 	89	 +  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x7E,  // 0x05
 	90	 +  0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E,  // 0x06
 	91	 +  0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, // 0x07
 	92	 +  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,  // 0x08
 	93	 +  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  // 0x09
 	94	 +  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, // 0x0A
 	95	 +  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, // 0x0B
 	96	 +  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, // 0x0C
 	97	 +  0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, // 0x0D
 	98	 +  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x0E
 	99	 +  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  // 0x0F
 	100	 +  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x10
 	101	 +  0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x11
 	102	 +  0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x12
 	103	 +  0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, // 0x13
 	104	 +  0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, // 0x14
 	105	 +  0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, // 0x15
 	106	 +  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,  // 0x16
 	107	 +  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF  // 0x17
 	108	 +};
 	109	 +
 	110	 +
 	111	 +/* ------------------------------------------------------------ */
 	112	 +/*    Procedure Definitions        */
 	113	 +/* ------------------------------------------------------------ */
 	114	 +/***  setup
 	115	 +**
 	116	 +**  Parameters:
 	117	 +**    none
 	118	 +**
 	119	 +**  Return Value:
 	120	 +**    none
 	121	 +**
 	122	 +**  Errors:
 	123	 +**    none
 	124	 +**
 	125	 +**  Description:
 	126	 +*/
 	127	 +
 	128	 +void
 	129	 +setup() {
 	130	 +  char  ch;  
 	131	 +
 	132	 +  /* Initialize the OLED display before access.
 	133	 +  */
 	134	 +  oled.begin();
 	135	 +  
 	136	 +  /* Define the user definable characters used in the demo.
 	137	 +  */
 	138	 +  for (ch = 0; ch < 0x18; ch++) {
 	139	 +    oled.defineUserChar(ch, &rgbUserFont[ch*cbOledChar]);
 	140	 +  }
 	141	 +
 	142	 +}
 	143	 +
 	144	 +/* ------------------------------------------------------------ */
 	145	 +/***  loop
 	146	 +**
 	147	 +**  Parameters:
 	148	 +**    none
 	149	 +**
 	150	 +**  Return Value:
 	151	 +**    none
 	152	 +**
 	153	 +**  Errors:
 	154	 +**    none
 	155	 +**
 	156	 +**  Description:
 	157	 +*/
 	158	 +
 	159	 +void
 	160	 +loop() {
 	161	 +
 	162	 +  drawBanner1();  
 	163	 +  delay(1000);
 	164	 +  
 	165	 +  drawSweepingLines();
 	166	 +  
 	167	 +  drawPixelDemo();
 	168	 +  delay(3000);
 	169	 +  
 	170	 +  drawLinePattern();
 	171	 +  delay(3000);
 	172	 +  
 	173	 +  fillRectDemo();
 	174	 +  
 	175	 +  drawRectDemo();
 	176	 +  delay(3000);
 	177	 +  
 	178	 +  putBmpDemo();
 	179	 +  
 	180	 +  putBmpEdgeTest();
 	181	 +  
 	182	 +  getBmpDemo();
 	183	 +  delay(2000);
 	184	 +  
 	185	 +  putStringDemo();
 	186	 +  delay(3000);
 	187	 +  
 	188	 +  putCharDemo();
 	189	 +  delay(3000);
 	190	 +  
 	191	 +  userCharDemo();
 	192	 +  delay(2000);
 	193	 +  
 	194	 +  graphicCharDemo();
 	195	 +  delay(2000);
 	196	 +  
 	197	 +}
 	198	 +
 	199	 +/* ------------------------------------------------------------ */
 	200	 +/***  drawBanner1
 	201	 +**
 	202	 +**  Parameters:
 	203	 +**    none
 	204	 +**
 	205	 +**  Return Value:
 	206	 +**    none
 	207	 +**
 	208	 +**  Errors
 	209	 +**    none
 	210	 +**
 	211	 +**  Description:
 	212	 +**    Draw the banner display. This draws a line advancing down
 	213	 +**    the screen with the display text appearing as it goes down.
 	214	 +**    The screen is then blinked three times, and then a line
 	215	 +**    works its way back up the screen erasing the text as it
 	216	 +**    goes.
 	217	 +*/
 	218	 +
 	219	 +void
 	220	 +drawBanner1() {
 	221	 +  
 	222	 +  int    row;
 	223	 +
 	224	 +  /* Fill pattern 0 is all black
 	225	 +  */ 
 	226	 +  oled.setFillPattern(oled.getStdPattern(0));
 	227	 +  
 	228	 +  /* Drawing mode to set pixels to the current color value.
 	229	 +  */
 	230	 +  oled.setDrawMode(OLED::modeSet);
 	231	 +  
 	232	 +  /* Color 1 is the pixel illuminated.
 	233	 +  */
 	234	 +  oled.setDrawColor(1);
 	235	 +  
 	236	 +  /* Turn off automatic display update after putting text.
 	237	 +  */
 	238	 +  oled.setCharUpdate(false);
 	239	 +  
 	240	 +  /* Draw the banner text. The text is drawn slowly from the
 	241	 +  ** top down. This is done by filling the display buffer with
 	242	 +  ** the text and then using drawFillRect to erase part of it.
 	243	 +  ** The upper edge of the part being erased is gradually moved
 	244	 +  ** down the display from the top.
 	245	 +  */
 	246	 +  for (row = 0; row < OLED::rowMax; row++) {
 	247	 +    
 	248	 +    /* Fill the display buffer with the banner text.
 	249	 +    */
 	250	 +    oled.clearBuffer();
 	251	 +    oled.setCursor(0, 0);
 	252	 +    oled.putString("chipKIT");
 	253	 +    oled.setCursor(0, 1);
 	254	 +    oled.putString("Basic I/O Shield");
 	255	 +    oled.setCursor(0, 2);
 	256	 +    oled.putString("by Digilent");
 	257	 +
 	258	 +    /* Erase everything below the current row and then draw
 	259	 +    ** a line across the display at the current row.
 	260	 +    */
 	261	 +    oled.moveTo(0, row);
 	262	 +    oled.drawFillRect(127,31);
 	263	 +    oled.moveTo(0,row);
 	264	 +    oled.drawLine(127,row);
 	265	 +    oled.updateDisplay();
 	266	 +    delay(100);
 	267	 +  }
 	268	 +  
 	269	 +  /* Clear the final line drawn.
 	270	 +  ** Draw color 0 is pixel not illuminated.
 	271	 +  */
 	272	 +  oled.setDrawColor(0);
 	273	 +  row -= 1;
 	274	 +  oled.moveTo(0, row);
 	275	 +  oled.drawLine(127, row);
 	276	 +  
 	277	 +  /* NOTE: Things don't show up on the display until
 	278	 +  ** updateDisplay is called (except for putChar and
 	279	 +  ** putString when auto update is enabled).
 	280	 +  */
 	281	 +  oled.updateDisplay();
 	282	 +  
 	283	 +  /* Blink the display.
 	284	 +  */
 	285	 +  delay(500);
 	286	 +  oled.displayOff();
 	287	 +  delay(500);
 	288	 +  oled.displayOn();
 	289	 +  delay(500);
 	290	 +  oled.displayOff();
 	291	 +  delay(500);
 	292	 +  oled.displayOn();
 	293	 +  delay(500);
 	294	 +  oled.displayOff();
 	295	 +  delay(500);
 	296	 +  oled.displayOn();
 	297	 +  delay(500);
 	298	 +
 	299	 +  /* Let it show for a while so that it can be seen
 	300	 +  */
 	301	 +  delay(2000);
 	302	 +
 	303	 +  /* Now erase the display. This is done by gradually
 	304	 +  ** erasing more and more of the text from the bottom up.
 	305	 +  ** This is done by drawing and erasing a line that
 	306	 +  ** gradually moves up the display.
 	307	 +  */
 	308	 +  oled.setDrawColor(1);
 	309	 +  
 	310	 +  for (row = OLED::rowMax-1; row >= 0; row--) {
 	311	 +    
 	312	 +    /* Draw a line across the current row.
 	313	 +    */
 	314	 +    oled.setDrawMode(OLED::modeSet);
 	315	 +    oled.moveTo(0,row);
 	316	 +    oled.drawLine(127,row);
 	317	 +    oled.updateDisplay();
 	318	 +    delay(25);
 	319	 +    
 	320	 +    /* Erase the line.
 	321	 +    */
 	322	 +    oled.setDrawMode(OLED::modeXor);
 	323	 +    oled.moveTo(0, row);
 	324	 +    oled.drawLine(127, row);
 	325	 +    oled.updateDisplay();
 	326	 +  }
 	327	 +
 	328	 +  /* Restore the default auto update behavior
 	329	 +  ** for the putChar and putString.
 	330	 +  */
 	331	 +  oled.setCharUpdate(true);
 	332	 +
 	333	 +}
 	334	 +
 	335	 +/* ------------------------------------------------------------ */
 	336	 +/***  drawSweepingLines
 	337	 +**
 	338	 +**  Parameters:
 	339	 +**    none
 	340	 +**
 	341	 +**  Return Value:
 	342	 +**    none
 	343	 +**
 	344	 +**  Errors:
 	345	 +**    none
 	346	 +**
 	347	 +**  Description:
 	348	 +**    This illustrates a simple animation by drawing two vertical
 	349	 +**    lines that start at the center and then move out to the left
 	350	 +**    and right edges of the display and then back to the center.
 	351	 +*/
 	352	 +
 	353	 +void
 	354	 +drawSweepingLines() {
 	355	 +  
 	356	 +  int    col;
 	357	 +
 	358	 +  oled.setDrawColor(1);
 	359	 +  oled.setDrawMode(OLED::modeSet);
 	360	 +
 	361	 +  for (col = 0; col < OLED::colMax/2; col++) {
 	362	 +    oled.clearBuffer();
 	363	 +    oled.moveTo(OLED::colMax/2 - col, 0);
 	364	 +    oled.drawLine(OLED::colMax/2 - col, OLED::rowMax-1);
 	365	 +    oled.moveTo(OLED::colMax/2 + col, 0);
 	366	 +    oled.drawLine(OLED::colMax/2 + col, OLED::rowMax-1);
 	367	 +    oled.updateDisplay();
 	368	 +    delay(10);
 	369	 +  }
 	370	 +
 	371	 +  for (col = OLED::colMax/2; col >= 0; col--) {
 	372	 +    oled.clearBuffer();
 	373	 +    oled.moveTo(OLED::colMax/2 - col, 0);
 	374	 +    oled.drawLine(OLED::colMax/2 - col, OLED::rowMax-1);
 	375	 +    oled.moveTo(OLED::colMax/2 + col, 0);
 	376	 +    oled.drawLine(OLED::colMax/2 + col, OLED::rowMax-1);
 	377	 +    oled.updateDisplay();
 	378	 +    delay(10);
 	379	 +  }  
 	380	 +  
 	381	 +}
 	382	 +
 	383	 +/* ------------------------------------------------------------ */
 	384	 +/***  drawPixelDemo
 	385	 +**
 	386	 +**  Parameters:
 	387	 +**    none
 	388	 +**
 	389	 +**  Return Value:
 	390	 +**    none
 	391	 +**
 	392	 +**  Errors:
 	393	 +**    none
 	394	 +**
 	395	 +**  Description:
 	396	 +**    This demonstrates using the drawPixel function. It draws
 	397	 +**    pairs of diagonal lines that end up creating a pattern
 	398	 +**    of X's on the display.
 	399	 +*/
 	400	 +
 	401	 +void
 	402	 +drawPixelDemo() {
 	403	 +  
 	404	 +  int    col;
 	405	 +  int    row;
 	406	 +  
 	407	 +  oled.clearBuffer();
 	408	 +  
 	409	 +  for (col = 0; col < OLED::colMax; col++) {
 	410	 +    if (col < OLED::colMax/4) {
 	411	 +      /* If in left quarter of display, draw up and to
 	412	 +      ** the right.
 	413	 +      */
 	414	 +      row = col;
 	415	 +    }
 	416	 +    else if (col < OLED::colMax/2) {
 	417	 +      /* If in the second quarter of the display,
 	418	 +      ** draw up down and to the right.
 	419	 +      */
 	420	 +      row = 31 - (col & 0x1F);
 	421	 +    }
 	422	 +    else if (col < 3*OLED::colMax/4) {
 	423	 +      /* If in the third quarter of the display,
 	424	 +      ** draw down and to the right.
 	425	 +      */
 	426	 +      row = col & 0x1F;
 	427	 +    }
 	428	 +    else {
 	429	 +      /* If in the right quarter of the display,
 	430	 +      ** draw down and to the right.
 	431	 +      */
 	432	 +      row = 31 - (col & 0x1F);
 	433	 +    }
 	434	 +    
 	435	 +    /* Draw the pixel.
 	436	 +    */
 	437	 +    oled.moveTo(col, row);
 	438	 +    oled.drawPixel();
 	439	 +    
 	440	 +    if (col < OLED::colMax/4) {
 	441	 +      row = 31 - (col & 0x1F);
 	442	 +    }
 	443	 +    else if (col < 64) {
 	444	 +      row = col & 0x1F;
 	445	 +    }
 	446	 +    else if (col < 96) {
 	447	 +      row = 31 - (col & 0x1F);
 	448	 +    }
 	449	 +    else {
 	450	 +      row = col & 0x1F;
 	451	 +    }
 	452	 +    
 	453	 +    /* Draw the pixel.
 	454	 +    */
 	455	 +    oled.moveTo(col, row);
 	456	 +    oled.drawPixel();
 	457	 +  }
 	458	 +  
 	459	 +  /* Update the display so that we can see the result.
 	460	 +  */
 	461	 +  oled.updateDisplay();
 	462	 +}
 	463	 +
 	464	 +/* ------------------------------------------------------------ */
 	465	 +/***  drawLinePattern
 	466	 +**
 	467	 +**  Parameters:
 	468	 +**    none
 	469	 +**
 	470	 +**  Return Value:
 	471	 +**    none
 	472	 +**
 	473	 +**  Errors:
 	474	 +**    none
 	475	 +**
 	476	 +**  Description:
 	477	 +**    This illustrates the use of the drawLine function. It draw a 
 	478	 +**    pattern of lines radiating out from the center of the display.
 	479	 +*/
 	480	 +
 	481	 +void
 	482	 +drawLinePattern() {
 	483	 +  int    col;
 	484	 +  int    row;
 	485	 +
 	486	 +  /* Clear the display buffer before drawing.
 	487	 +  */ 
 	488	 +  oled.clearBuffer();
 	489	 +  
 	490	 +  /* Draw a series of lines from the center of the display to
 	491	 +  ** points along the top.
 	492	 +  */
 	493	 +  for (col = 0; col < OLED::colMax; col += 16) {
 	494	 +    oled.moveTo(OLED::colMax/2, OLED::rowMax/2);
 	495	 +    oled.drawLine(col, 0);
 	496	 +  }
 	497	 +
 	498	 +  /* Draw a series of lines from the center of the display to
 	499	 +  ** points along the right edge.
 	500	 +  */
 	501	 +  for (row = 0; row < OLED::rowMax; row += 8) {
 	502	 +    oled.moveTo(OLED::colMax/2, OLED::rowMax/2);
 	503	 +    oled.drawLine(OLED::colMax-1, row);
 	504	 +  }
 	505	 +
 	506	 +  /* Draw a series of lines from the center of the display to
 	507	 +  ** points along the bottom.
 	508	 +  */
 	509	 +  for (col = 0; col < OLED::colMax; col += 16) {
 	510	 +    oled.moveTo(OLED::colMax/2, OLED::rowMax/2);
 	511	 +    oled.drawLine(col, OLED::rowMax-1);
 	512	 +  }
 	513	 +
 	514	 +  /* Draw a series of lines from the center of the display to
 	515	 +  ** points along the left edge.
 	516	 +  */
 	517	 +  for (row = 0; row < OLED::rowMax; row += 8) {
 	518	 +    oled.moveTo(OLED::colMax/2, OLED::rowMax/2);
 	519	 +    oled.drawLine(0, row);
 	520	 +  }
 	521	 +
 	522	 +  /* Update the display so that we can see the result.
 	523	 +  */
 	524	 +  oled.updateDisplay();
 	525	 +
 	526	 +}
 	527	 +
 	528	 +/* ------------------------------------------------------------ */
 	529	 +/***  fillRectDemo
 	530	 +**
 	531	 +**  Parameters:
 	532	 +**      none
 	533	 +**
 	534	 +**  Return Value:
 	535	 +**      none
 	536	 +**
 	537	 +**  Errors:
 	538	 +**      none
 	539	 +**
 	540	 +**  Description:
 	541	 +**    Illuarate drawing filled rectangles. This cycles through the
 	542	 +**    defined fill patterns drawing some rectangles. Note, that
 	543	 +**    the drawFillRect function doesn't draw the lines framing the
 	544	 +**    rectangle. That is done using drawRect.
 	545	 +*/
 	546	 +
 	547	 +void
 	548	 +fillRectDemo() {
 	549	 +  int    ib;
 	550	 +
 	551	 +  /* Cycle through the defined fill patterns.
 	552	 +  */  
 	553	 +  for (ib = 1; ib < 8; ib++) {
 	554	 +    /* Blank the display buffer before drawing this iteration
 	555	 +    */
 	556	 +    oled.clearBuffer();
 	557	 +
 	558	 +    /* Select the fill pattern.
 	559	 +    */  
 	560	 +    oled.setFillPattern(oled.getStdPattern(ib));
 	561	 +    
 	562	 +    /* Draw some rectangles with fill.
 	563	 +    */
 	564	 +    oled.moveTo(5, 1);
 	565	 +    oled.drawFillRect(25, 5);
 	566	 +    oled.drawRect(25,5);
 	567	 +    oled.updateDisplay();
 	568	 +  
 	569	 +    oled.moveTo(30, 1);
 	570	 +    oled.drawFillRect(50,10);
 	571	 +    oled.drawRect(50,10);
 	572	 +    oled.updateDisplay();
 	573	 +  
 	574	 +    oled.moveTo(55, 1);
 	575	 +    oled.drawFillRect(75, 27);
 	576	 +    oled.drawRect(75,27);
 	577	 +    oled.updateDisplay();
 	578	 +  
 	579	 +    oled.moveTo(80, 8);
 	580	 +    oled.drawFillRect(105, 23);
 	581	 +    oled.drawRect(105,23);
 	582	 +    
 	583	 +    /* Update the display so that we can see the result.
 	584	 +    */
 	585	 +    oled.updateDisplay();
 	586	 +    
 	587	 +    delay(1000);
 	588	 +  }
 	589	 +}
 	590	 +
 	591	 +/* ------------------------------------------------------------ */
 	592	 +/***  drawRectDemo
 	593	 +**
 	594	 +**  Parameters:
 	595	 +**    none
 	596	 +**
 	597	 +**  Return Value:
 	598	 +**    none
 	599	 +**
 	600	 +**  Errors:
 	601	 +**    none
 	602	 +**
 	603	 +**  Description:
 	604	 +**    Demonstrate drawing rectangles. This does a simple animiation
 	605	 +**    by drawing two pairs of rectangles that start at the left
 	606	 +**    and right sides of the display and move toward the center.
 	607	 +*/
 	608	 +
 	609	 +void
 	610	 +drawRectDemo() {
 	611	 +    int    xco1;
 	612	 +    int    yco1;
 	613	 +    int    xco2;
 	614	 +    int    yco2;
 	615	 +
 	616	 +  /* One pair of rectanges start at the left
 	617	 +  */  
 	618	 +  xco1 = 5;
 	619	 +  yco1 = 5;
 	620	 +
 	621	 +  /* The other pair starts at the right.
 	622	 +  */
 	623	 +  xco2 = 122;
 	624	 +  yco2 = 26;
 	625	 +
 	626	 +  while (xco1 < xco2) {
 	627	 +    /* Clear the buffer before drawing this frame of the
 	628	 +    ** animation.
 	629	 +    */
 	630	 +    oled.clearBuffer();
 	631	 +
 	632	 +    /* Draw the two rectangels on the left.
 	633	 +    ** They are 15 pixels wide x 5 pixels high.
 	634	 +    */  
 	635	 +    oled.moveTo(xco1, yco1);
 	636	 +    oled.drawRect(xco1+15, yco1+5);
 	637	 +  
 	638	 +    oled.moveTo(xco1, yco2);
 	639	 +    oled.drawRect(xco1+15, yco2-5);
 	640	 +
 	641	 +    /* Draw the two rectangles on the right.
 	642	 +    */  
 	643	 +    oled.moveTo(xco2, yco1);
 	644	 +    oled.drawRect(xco2-15, yco1+5);
 	645	 +  
 	646	 +    oled.moveTo(xco2, yco2);
 	647	 +    oled.drawRect(xco2-15, yco2-5);
 	648	 +
 	649	 +    /* Update the display so we can see the result and
 	650	 +    ** then delay slightly so that the animation progresses
 	651	 +    ** at a reasonable pace.
 	652	 +    */  
 	653	 +    oled.updateDisplay();
 	654	 +    delay(10);
 	655	 +
 	656	 +    /* Move toward the center of the display.
 	657	 +    */
 	658	 +    xco1 += 1;
 	659	 +    xco2 -= 1;
 	660	 +  }
 	661	 +  
 	662	 +}
 	663	 +
 	664	 +/* ------------------------------------------------------------ */
 	665	 +/***  putBmpDemo
 	666	 +**
 	667	 +**  Parameters:
 	668	 +**    none
 	669	 +**
 	670	 +**  Return Value:
 	671	 +**    none
 	672	 +**
 	673	 +**  Errors:
 	674	 +**    none
 	675	 +**
 	676	 +**  Description:
 	677	 +**    Illustrate using the putBmp function to draw a bitmap on
 	678	 +**    the display. The bitmap is defined in the array rgbBmp0.
 	679	 +**    This also illustrates drawing only portions of the bitmap
 	680	 +**    by specifying different sizes to put.
 	681	 +**    The pattern of bitmaps is animated by moving down and to
 	682	 +**    the right until it reaches the bottom of the display and
 	683	 +**    then up and to the left.
 	684	 +*/
 	685	 +
 	686	 +void
 	687	 +putBmpDemo() {
 	688	 +  int  yco;
 	689	 +  int  xco;
 	690	 +
 	691	 +  /* Start at the top of the display.
 	692	 +  */  
 	693	 +  yco = 0;
 	694	 +  
 	695	 +  /* Increase X so that we move to the right.
 	696	 +  */
 	697	 +  for (xco = 0; xco < 30; xco++) {
 	698	 +    /* Clear the display buffer before drawing this iteration.
 	699	 +    */
 	700	 +    oled.clearBuffer();
 	701	 +
 	702	 +    /* Do some putBmp calls to draw different portions
 	703	 +    ** of the bitmap spaced out to the right.
 	704	 +    */
 	705	 +    oled.moveTo(8+xco, yco);
 	706	 +    oled.putBmp(8, 4, rgbBmp0);
 	707	 +
 	708	 +    oled.moveTo(18+xco, yco);
 	709	 +    oled.putBmp(8, 6, rgbBmp0);
 	710	 +  
 	711	 +    oled.moveTo(28+xco, yco);
 	712	 +    oled.putBmp(8, 8, rgbBmp0);
 	713	 +  
 	714	 +    oled.moveTo(38+xco, yco);
 	715	 +    oled.putBmp(8, 10, rgbBmp0);
 	716	 +  
 	717	 +    oled.moveTo(48+xco, yco);
 	718	 +    oled.putBmp(8, 12, rgbBmp0);
 	719	 +
 	720	 +    oled.moveTo(58+xco, yco);
 	721	 +    oled.putBmp(8, 14, rgbBmp0);
 	722	 +
 	723	 +    oled.moveTo(68+xco, yco);
 	724	 +    oled.putBmp(8, 16, rgbBmp0);
 	725	 +
 	726	 +    /* Update the display so that we can see the result.
 	727	 +    */
 	728	 +    oled.updateDisplay();
 	729	 +
 	730	 +    /* Move down for a while, and then move up.
 	731	 +    */
 	732	 +    if (xco <= 15) {
 	733	 +      yco += 1;
 	734	 +    }
 	735	 +    else {
 	736	 +      yco -= 1;
 	737	 +    }
 	738	 +
 	739	 +    delay(100);
 	740	 +  }
 	741	 +}
 	742	 +
 	743	 +/* ------------------------------------------------------------ */
 	744	 +/***  putBmpEdgeTest
 	745	 +**
 	746	 +**  Parameters:
 	747	 +**    none
 	748	 +**
 	749	 +**  Return Value:
 	750	 +**    none
 	751	 +**
 	752	 +**  Errors:
 	753	 +**    none
 	754	 +**
 	755	 +**  Description:
 	756	 +**    This illustrates clipping of bitmaps at the edges of the display
 	757	 +*/
 	758	 +
 	759	 +void
 	760	 +putBmpEdgeTest() {
 	761	 +    int  xco;
 	762	 +    int  yco;
 	763	 +
 	764	 +  /* Test moving the bitmap off the screen to the right.
 	765	 +  */
 	766	 +  for (xco = OLED::colMax-16; xco < OLED::colMax; xco++) {
 	767	 +    oled.clearBuffer();
 	768	 +    oled.moveTo(xco, 8);
 	769	 +    oled.putBmp(8, 16, rgbBmp0);
 	770	 +    oled.updateDisplay();
 	771	 +    delay(100);
 	772	 +  }
 	773	 +
 	774	 +  /* Test moving the bitmap off the screen to the bottom.
 	775	 +  */
 	776	 +  for (yco = 8; yco < OLED::rowMax; yco++) {
 	777	 +    oled.clearBuffer();
 	778	 +    oled.moveTo(40, yco);
 	779	 +    oled.putBmp(8, 16, rgbBmp0);
 	780	 +    oled.updateDisplay();
 	781	 +    delay(100);
 	782	 +  }  
 	783	 +}
 	784	 +
 	785	 +/* ------------------------------------------------------------ */
 	786	 +/***  getBmpDemo
 	787	 +**
 	788	 +**  Parameters:
 	789	 +**    none
 	790	 +**
 	791	 +**  Return Value:
 	792	 +**    none
 	793	 +**
 	794	 +**  Errors:
 	795	 +**    none
 	796	 +**
 	797	 +**  Description:
 	798	 +**    Demonstrate reading a bitmap off of the display, and then
 	799	 +**    writing it back to the display in another location.
 	800	 +*/
 	801	 +
 	802	 +void
 	803	 +getBmpDemo() {
 	804	 +  int    ib;
 	805	 +
 	806	 +  /* Clear the display buffer before we draw anything.
 	807	 +  */  
 	808	 +  oled.clearBuffer();
 	809	 +  
 	810	 +  /* Iterate down and to the right. This uses putBmp to write
 	811	 +  ** something into the display buffer. It then uses getBmp
 	812	 +  ** to read that portion of the display buffer, and then putBmp
 	813	 +  ** again to write what was read back to another place on the
 	814	 +  ** display.
 	815	 +  ** putBmp was used in this case to put something into the
 	816	 +  ** display buffer initially, but that is not a requirement.
 	817	 +  ** Any drawing functions can be used to write into the display
 	818	 +  ** before calling getBmp to read it into an offscreen bitmap.
 	819	 +  */
 	820	 +  for (ib = 0; ib < 8; ib++) {
 	821	 +    /* Write a pattern into the display.
 	822	 +    */
 	823	 +    oled.moveTo(8*ib+4, ib);
 	824	 +    oled.putBmp(8, 8, rgbBmp0);
 	825	 +    
 	826	 +    /* Read the pattern back into an offscreen bitmap.
 	827	 +    */
 	828	 +    oled.moveTo(8*ib+4, ib);
 	829	 +    oled.getBmp(8, 8, rgbBmp1);
 	830	 +    
 	831	 +    /* Write the offscreen bitmap back to another place on
 	832	 +    ** the display.
 	833	 +    */
 	834	 +    oled.moveTo(8*ib+4, 16+ib);
 	835	 +    oled.putBmp(8, 8, rgbBmp1);
 	836	 +    
 	837	 +    /* Update the display so that we can see the result.
 	838	 +    */
 	839	 +    oled.updateDisplay();
 	840	 +    delay(500);
 	841	 +  }
 	842	 +  
 	843	 +}
 	844	 +
 	845	 +/* ------------------------------------------------------------ */
 	846	 +/***  putCharDemo
 	847	 +**
 	848	 +**  Parameters:
 	849	 +**    none
 	850	 +**
 	851	 +**  Return Value:
 	852	 +**    none
 	853	 +**
 	854	 +**  Errors:
 	855	 +**    none
 	856	 +**
 	857	 +**  Description:
 	858	 +**    Demonstrate using the putChar function to write ASCII
 	859	 +**    characters into the display.
 	860	 +**    Note: this example doesn't clear the display before
 	861	 +**    putting the characters. This means that the characters
 	862	 +**    put to the display will gradually write over what was
 	863	 +**    on the display when it began.
 	864	 +**    Note also that there are no calls to updateDisplay. The
 	865	 +**    character mode functions putChar and putString will
 	866	 +**    automatically update the display after each call.
 	867	 +**    This auto-update can be turned on or off using the
 	868	 +**    setCharUpdate.
 	869	 +**    Note also that the printing wraps when it gets to the
 	870	 +**    right side of the display. It will also wrap from the
 	871	 +**    bottom to the top.
 	872	 +*/
 	873	 +
 	874	 +void
 	875	 +putCharDemo() {
 	876	 +  int    ib;
 	877	 +
 	878	 +  /* Start at the upper left of the display.
 	879	 +  */  
 	880	 +  oled.setCursor(0, 0);
 	881	 +  
 	882	 +  /* Generate the printable ASCII characters in order.
 	883	 +  ** The printable characters start with 'A'.
 	884	 +  */
 	885	 +  for (ib = 0; ib < 64; ib ++) {
 	886	 +    oled.putChar('A'+ib);
 	887	 +    delay(100);
 	888	 +  }
 	889	 +
 	890	 +}
 	891	 +
 	892	 +/* ------------------------------------------------------------ */
 	893	 +/***  putStringDemo
 	894	 +**
 	895	 +**  Parameters:
 	896	 +**    none
 	897	 +**
 	898	 +**  Return Value:
 	899	 +**    none
 	900	 +**
 	901	 +**  Errors:
 	902	 +**    none
 	903	 +**
 	904	 +**  Description:
 	905	 +**    Demonstrate using setCursor and putString to write ASCII
 	906	 +**    character strings to the display.
 	907	 +**    Note that there are no calls to updateDisplay. The
 	908	 +**    character mode functions putChar and putString will
 	909	 +**    automatically update the display after each call.
 	910	 +**    This auto-update can be turned on or off using the
 	911	 +**    setCharUpdate.
 	912	 +*/
 	913	 +
 	914	 +void
 	915	 +putStringDemo() {
 	916	 +
 	917	 +  /* Clear the display. Note that clear has the same effect as
 	918	 +  ** calling clearBuffer and updateDisplay.
 	919	 +  */  
 	920	 +  oled.clear();
 	921	 +
 	922	 +  /* Write some strings to the display.
 	923	 +  */
 	924	 +  oled.setCursor(0, 0);
 	925	 +  oled.putString("First Line");
 	926	 +  oled.setCursor(1, 1);
 	927	 +  oled.putString("Second Line");
 	928	 +  oled.setCursor(2, 2);
 	929	 +  oled.putString("Third Line");
 	930	 +  oled.setCursor(3, 3);
 	931	 +  oled.putString("Fourth Line");
 	932	 +  
 	933	 +}
 	934	 +
 	935	 +/* ------------------------------------------------------------ */
 	936	 +/***  userCharDemo
 	937	 +**
 	938	 +**  Parameters:
 	939	 +**    none
 	940	 +**
 	941	 +**  Return Value:
 	942	 +**    none
 	943	 +**
 	944	 +**  Errors:
 	945	 +**    none
 	946	 +**
 	947	 +**  Description:
 	948	 +**    Demonstrate the use of user defined characters. The first
 	949	 +**    32 code values in the ASCII character are control characters
 	950	 +**    and don't have a defined glyph. In this library, those codes
 	951	 +**    are used for user defined characters. The code values for the
 	952	 +**    user defined characters are 0x00 through 0x1F (or 0 to 31 in
 	953	 +**    decimal). These can be written using any function that can be
 	954	 +**    used to write characters: (putChar, putString, drawChar, 
 	955	 +**    drawString).
 	956	 +**    The library was given the glyphs for the user defined character
 	957	 +**    set in the setup() function.
 	958	 +*/
 	959	 +
 	960	 +void
 	961	 +userCharDemo() {
 	962	 +  int    ib;
 	963	 +
 	964	 +  /* Clear the display.
 	965	 +  */  
 	966	 +  oled.clear();
 	967	 +
 	968	 +  /* Write some regular text as a header on the first two lines.
 	969	 +  */
 	970	 +  oled.setCursor(0, 0);
 	971	 +  oled.putString("User Defined");
 	972	 +  oled.setCursor(0, 1);
 	973	 +  oled.putString("Characters");
 	974	 +
 	975	 +  /* Write the user defined characters on the lower two lines.
 	976	 +  */
 	977	 +  oled.setCursor(0, 2);
 	978	 +  for (ib = 0; ib < 32; ib++) {
 	979	 +    oled.putChar(ib);
 	980	 +    delay(100);
 	981	 +  }
 	982	 +
 	983	 +}
 	984	 +
 	985	 +/* ------------------------------------------------------------ */
 	986	 +/***  graphicCharDemo
 	987	 +**
 	988	 +**  Parameters:
 	989	 +**    none
 	990	 +**
 	991	 +**  Return Value:
 	992	 +**    none
 	993	 +**
 	994	 +**  Errors:
 	995	 +**    none
 	996	 +**
 	997	 +**  Description:
 	998	 +**    Demonstrate drawing text as 'graphic characters'
 	999	 +**    The OLED display library supports two 'modes' of drawing text:
 	1000	 +**    character mode and graphics mode. Strictly speaking, these
 	1001	 +**    aren't really modes at all as call to the two styles of
 	1002	 +**    character functions can be mixed at will.
 	1003	 +**    The character functions (putChar, putString) use cursor
 	1004	 +**    positions that are in terms of character column and character
 	1005	 +**    row. These treat the display as if it were a 16x4 character
 	1006	 +**    mode LCD display. the character mode functions also have the
 	1007	 +**    auto-update behavior, so that the updateDisplay function
 	1008	 +**    doesn't need to be called when using them.
 	1009	 +**    The graphics functions (drawChar and drawString) use the
 	1010	 +**    graphical coordinates and allow drawing characters at any
 	1011	 +**    location on the display. The drawChar function is effectively
 	1012	 +**    the same as putBmp where the bitmap is defined internally in
 	1013	 +**    the library's character table. The grahics functions don't
 	1014	 +**    automatically update the display.
 	1015	 +*/
 	1016	 +
 	1017	 +void
 	1018	 +graphicCharDemo() {
 	1019	 +  int  ib;
 	1020	 +  int  xco1;
 	1021	 +  int  yco1;
 	1022	 +  int  xco2;
 	1023	 +  int  yco2;
 	1024	 +  
 	1025	 +  xco1 = 0;
 	1026	 +  yco1 = 0;
 	1027	 +  xco2 = 64;
 	1028	 +  yco2 = 23;
 	1029	 +
 	1030	 +  /* Draw some text as a banner describing what is being
 	1031	 +  ** demonstrated.
 	1032	 +  */
 	1033	 +  oled.clearBuffer();
 	1034	 +  oled.moveTo(8, 8);
 	1035	 +  oled.drawString("Graphic");
 	1036	 +  oled.moveTo(32, 16);
 	1037	 +  oled.drawString("Characters");
 	1038	 +  oled.updateDisplay();
 	1039	 +  
 	1040	 +  /* Pause so that the user can see it.
 	1041	 +  */
 	1042	 +  delay(2000);
 	1043	 +
 	1044	 +  /* Do a simple animation moving a couple of strings
 	1045	 +  ** around on the display.
 	1046	 +  */
 	1047	 +  for (ib = 0; ib < 16; ib++) {
 	1048	 +    oled.clearBuffer();
 	1049	 +    oled.moveTo(xco1+ib, yco1+ib);
 	1050	 +    oled.drawString("ABC");
 	1051	 +    oled.moveTo(xco2-ib, yco2-ib);
 	1052	 +    oled.drawString("DEF");
 	1053	 +    oled.updateDisplay();
 	1054	 +    delay(100);
 	1055	 +  }
 	1056	 +}
 	1057	 +
 	1058	 +/* ------------------------------------------------------------ */
 	1059	 +
 	1060	 +/************************************************************************/
 	1061	 +
 	1062	 +  
 	1063	 +  
 	1064	 +  
60 ????? lib/IOShieldOled/keywords.txt View file @ 5a843cc
...	...	 @@ -0,0 +1,60 @@
 	1	 +#######################################
 	2	 +# Syntax Coloring Map For IOShieldOLED
 	3	 +#######################################
 	4	 +
 	5	 +#######################################
 	6	 +# Datatypes (KEYWORD1)
 	7	 +#######################################
 	8	 +
 	9	 +#######################################
 	10	 +# Methods and Functions (KEYWORD2)
 	11	 +#######################################
 	12	 +
 	13	 +begin  KEYWORD2
 	14	 +end   KEYWORD2
 	15	 +displayOn  KEYWORD2
 	16	 +displayOff  KEYWORD2
 	17	 +clear  KEYWORD2
 	18	 +clearBuffer  KEYWORD2
 	19	 +updateDisplay  KEYWORD2
 	20	 +setCursor  KEYWORD2
 	21	 +getCursor  KEYWORD2
 	22	 +defineUserChar  KEYWORD2
 	23	 +setCharUpdate  KEYWORD2
 	24	 +getCharUpdate  KEYWORD2
 	25	 +putChar  KEYWORD2
 	26	 +putString  KEYWORD2
 	27	 +setDrawColor  KEYWORD2
 	28	 +setDrawMode  KEYWORD2
 	29	 +getDrawMode  KEYWORD2
 	30	 +getStdPattern  KEYWORD2
 	31	 +setFillPattern  KEYWORD2
 	32	 +moveTo  KEYWORD2
 	33	 +getPos  KEYWORD2
 	34	 +drawPixel  KEYWORD2
 	35	 +getPixel  KEYWORD2
 	36	 +drawLine  KEYWORD2
 	37	 +drawRect  KEYWORD2
 	38	 +drawFillRect  KEYWORD2
 	39	 +getBmp  KEYWORD2
 	40	 +putBmp  KEYWORD2
 	41	 +drawChar  KEYWORD2
 	42	 +drawString  KEYWORD2
 	43	 +
 	44	 +#######################################
 	45	 +# Instances (KEYWORD2)
 	46	 +#######################################
 	47	 +
 	48	 +IOShieldOled  KEYWORD2
 	49	 +
 	50	 +#######################################
 	51	 +# Constants (LITERAL1)
 	52	 +#######################################
 	53	 +
 	54	 +colMax  LITERAL1
 	55	 +rowMax  LITERAL1
 	56	 +pageMax  LITERAL1
 	57	 +modeSet  LITERAL1
 	58	 +modeOr  LITERAL1
 	59	 +modeAnd  LITERAL1
 	60	 +modeXor  LITERAL1
196 ????? lib/IOShieldOled/utility/ChrFont0.c View file @ 5a843cc
...	...	 @@ -0,0 +1,196 @@
 	1	 +
 	2	 +/************************************************************************/
 	3	 +/*                                    */
 	4	 +/*  ChrFont0.c  --  Data Definitions for Character Font Table      */
 	5	 +/*                                    */
 	6	 +/************************************************************************/
 	7	 +/*  Author:   Gene Apperson                      */
 	8	 +/*  Copyright 2011, Digilent Inc.                    */
 	9	 +/************************************************************************/
 	10	 +/*
 	11	 +  This library is free software; you can redistribute it and/or
 	12	 +  modify it under the terms of the GNU Lesser General Public
 	13	 +  License as published by the Free Software Foundation; either
 	14	 +  version 2.1 of the License, or (at your option) any later version.
 	15	 +
 	16	 +  This library is distributed in the hope that it will be useful,
 	17	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	18	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	19	 +  Lesser General Public License for more details.
 	20	 +
 	21	 +  You should have received a copy of the GNU Lesser General Public
 	22	 +  License along with this library; if not, write to the Free Software
 	23	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	24	 +*/
 	25	 +/************************************************************************/
 	26	 +/*  Module Description:                         */
 	27	 +/*                                    */
 	28	 +/*  This module contains the data definitions for an 8x8 pixel ASCII  */
 	29	 +/*  character font. This table doesn't contains definitions for glyphs  */
 	30	 +/*  for character codes 0x00-0x1F. These character codes are mapped to  */
 	31	 +/*  the user defined character table.                  */
 	32	 +/*                                    */
 	33	 +/*  This character table is defined for a display where each byte     */
 	34	 +/*  represents 8 vertical pixels and consecutive bytes give adjacent  */
 	35	 +/*  sets of 8 vertical pixels progressing to the right across the    */
 	36	 +/*  display. This is rotated 90 degrees from the conventional video    */
 	37	 +/*  display orientation.                        */
 	38	 +/*                                    */
 	39	 +/************************************************************************/
 	40	 +/*  Revision History:                          */
 	41	 +/*                                    */
 	42	 +/*  06/08/2011(GeneA): created                      */
 	43	 +/*                                    */
 	44	 +/************************************************************************/
 	45	 +
 	46	 +/* ------------------------------------------------------------ */
 	47	 +/*        Include File Definitions            */
 	48	 +/* ------------------------------------------------------------ */
 	49	 +
 	50	 +#include <p32xxxx.h>
 	51	 +#include <plib.h>
 	52	 +
 	53	 +/* ------------------------------------------------------------ */
 	54	 +/*        Global Variables                */
 	55	 +/* ------------------------------------------------------------ */
 	56	 +
 	57	 +const BYTE rgbOledFont0[] = {
 	58	 +#if defined(DEAD)
 	59	 +  /* Remove definitions for character codes 0x00-0x1F as
 	60	 +  ** these are map to user defined characters.
 	61	 +  */
 	62	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x00, NUL
 	63	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x01, SOH
 	64	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x02, STX
 	65	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, ETX
 	66	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, EOT
 	67	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x05, ENQ
 	68	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x06, ACK
 	69	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x07, BEL
 	70	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x08, BS
 	71	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x09, HT
 	72	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0A, LF
 	73	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0B, VT
 	74	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0C, FF
 	75	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0D, CR
 	76	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0E, SO
 	77	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0F, SI
 	78	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x10, DLE
 	79	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x11, DC1
 	80	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x12, DC2
 	81	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC3
 	82	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC4
 	83	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x15, NAK
 	84	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x16, SYN
 	85	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x17, ETB
 	86	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x18, CAN
 	87	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x19, EM
 	88	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1A, SUB
 	89	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1B, ESC
 	90	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1C, FS
 	91	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1D, GS
 	92	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1E, RS
 	93	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1F, US
 	94	 +#endif
 	95	 +  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x20, space
 	96	 +  0x00,0x00,0x00,0x5f,0x00,0x00,0x00,0x00,    // 0x21, !
 	97	 +  0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,    // 0x22, "
 	98	 +  0x64,0x3c,0x26,0x64,0x3c,0x26,0x24,0x00,    // 0x23, #
 	99	 +  0x26,0x49,0x49,0x7f,0x49,0x49,0x32,0x00,    // 0x23, $
 	100	 +  0x42,0x25,0x12,0x08,0x24,0x52,0x21,0x00,    // 0x25, %
 	101	 +  0x20,0x50,0x4e,0x55,0x22,0x58,0x28,0x00,    // 0x26, &
 	102	 +  0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,    // 0x27, '
 	103	 +  0x00,0x00,0x1c,0x22,0x41,0x00,0x00,0x00,    // 0x28, (
 	104	 +  0x00,0x00,0x00,0x41,0x22,0x1c,0x00,0x00,    // 0x29, )
 	105	 +  0x00,0x15,0x15,0x0e,0x0e,0x15,0x15,0x00,    // 0x2A, *
 	106	 +  0x00,0x08,0x08,0x3e,0x08,0x08,0x00,0x00,    // 0x2B, +
 	107	 +  0x00,0x00,0x00,0x50,0x30,0x00,0x00,0x00,    // 0x2C, ,
 	108	 +  0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00,    // 0x2D, -
 	109	 +  0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,    // 0x2E, .
 	110	 +  0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00,    // 0x2F, /
 	111	 +  0x00,0x3e,0x41,0x41,0x41,0x3e,0x00,0x00,    // 0x30, 0
 	112	 +  0x00,0x00,0x41,0x7f,0x40,0x00,0x00,0x00,    // 0x31, 1
 	113	 +  0x00,0x42,0x61,0x51,0x49,0x6e,0x00,0x00,    // 0x32, 2
 	114	 +  0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00,    // 0x33, 3
 	115	 +  0x00,0x18,0x14,0x12,0x7f,0x10,0x00,0x00,    // 0x33, 4
 	116	 +  0x00,0x27,0x49,0x49,0x49,0x71,0x00,0x00,    // 0x35, 5
 	117	 +  0x00,0x3c,0x4a,0x49,0x48,0x70,0x00,0x00,    // 0x36, 6
 	118	 +  0x00,0x43,0x21,0x11,0x0d,0x03,0x00,0x00,    // 0x37, 7
 	119	 +  0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00,    // 0x38, 8
 	120	 +  0x00,0x06,0x09,0x49,0x29,0x1e,0x00,0x00,    // 0x39, 9
 	121	 +  0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,    // 0x3A, :
 	122	 +  0x00,0x00,0x00,0x52,0x30,0x00,0x00,0x00,    // 0x3B, //
 	123	 +  0x00,0x00,0x08,0x14,0x14,0x22,0x00,0x00,    // 0x3C, <
 	124	 +  0x00,0x14,0x14,0x14,0x14,0x14,0x14,0x00,    // 0x3D, =
 	125	 +  0x00,0x00,0x22,0x14,0x14,0x08,0x00,0x00,    // 0x3E, >
 	126	 +  0x00,0x02,0x01,0x59,0x05,0x02,0x00,0x00,    // 0x3F, ?
 	127	 +  0x3e,0x41,0x5d,0x55,0x4d,0x51,0x2e,0x00,    // 0x40, @
 	128	 +  0x40,0x7c,0x4a,0x09,0x4a,0x7c,0x40,0x00,    // 0x41, A
 	129	 +  0x41,0x7f,0x49,0x49,0x49,0x49,0x36,0x00,    // 0x42, B
 	130	 +  0x1c,0x22,0x41,0x41,0x41,0x41,0x22,0x00,    // 0x43, C
 	131	 +  0x41,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x44, D
 	132	 +  0x41,0x7f,0x49,0x49,0x5d,0x41,0x63,0x00,    // 0x45, E
 	133	 +  0x41,0x7f,0x49,0x09,0x1d,0x01,0x03,0x00,    // 0x46, F
 	134	 +  0x1c,0x22,0x41,0x49,0x49,0x3a,0x08,0x00,    // 0x47, G
 	135	 +  0x41,0x7f,0x08,0x08,0x08,0x7f,0x41,0x00,    // 0x48, H
 	136	 +  0x00,0x41,0x41,0x7F,0x41,0x41,0x00,0x00,    // 0x49, I
 	137	 +  0x30,0x40,0x41,0x41,0x3F,0x01,0x01,0x00,    // 0x4A, J
 	138	 +  0x41,0x7f,0x08,0x0c,0x12,0x61,0x41,0x00,    // 0x4B, K
 	139	 +  0x41,0x7f,0x41,0x40,0x40,0x40,0x60,0x00,    // 0x4C, L
 	140	 +  0x41,0x7f,0x42,0x0c,0x42,0x7f,0x41,0x00,    // 0x4D, M
 	141	 +  0x41,0x7f,0x42,0x0c,0x11,0x7f,0x01,0x00,    // 0x4E, N
 	142	 +  0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x4F, O
 	143	 +  0x41,0x7f,0x49,0x09,0x09,0x09,0x06,0x00,    // 0x50, P
 	144	 +  0x0c,0x12,0x21,0x21,0x61,0x52,0x4c,0x00,    // 0x51, Q
 	145	 +  0x41,0x7f,0x09,0x09,0x19,0x69,0x46,0x00,    // 0x52, R
 	146	 +  0x66,0x49,0x49,0x49,0x49,0x49,0x33,0x00,    // 0x53, S
 	147	 +  0x03,0x01,0x41,0x7f,0x41,0x01,0x03,0x00,    // 0x54, T
 	148	 +  0x01,0x3f,0x41,0x40,0x41,0x3f,0x01,0x00,    // 0x55, U
 	149	 +  0x01,0x0f,0x31,0x40,0x31,0x0f,0x01,0x00,    // 0x56, V
 	150	 +  0x01,0x1f,0x61,0x14,0x61,0x1f,0x01,0x00,    // 0x57, W
 	151	 +  0x41,0x41,0x36,0x08,0x36,0x41,0x41,0x00,    // 0x58, X
 	152	 +  0x01,0x03,0x44,0x78,0x44,0x03,0x01,0x00,    // 0x59, Y
 	153	 +  0x43,0x61,0x51,0x49,0x45,0x43,0x61,0x00,    // 0x5A, Z
 	154	 +  0x00,0x00,0x7f,0x41,0x41,0x00,0x00,0x00,    // 0x5B, [
 	155	 +  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x00,    // 0x5C,
 	156	 +  0x00,0x00,0x41,0x41,0x7f,0x00,0x00,0x00,    // 0x5D, ]
 	157	 +  0x00,0x04,0x02,0x01,0x01,0x02,0x04,0x00,    // 0x5E, ^
 	158	 +  0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,    // 0x5F, _
 	159	 +  0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,    // 0x60, `
 	160	 +  0x00,0x34,0x4a,0x4a,0x4a,0x3c,0x40,0x00,    // 0x61, a
 	161	 +  0x00,0x41,0x3f,0x48,0x48,0x48,0x30,0x00,    // 0x62. b
 	162	 +  0x00,0x3c,0x42,0x42,0x42,0x24,0x00,0x00,    // 0x63, c
 	163	 +  0x00,0x30,0x48,0x48,0x49,0x3f,0x40,0x00,    // 0x63, d
 	164	 +  0x00,0x3c,0x4a,0x4a,0x4a,0x2c,0x00,0x00,    // 0x65, e
 	165	 +  0x00,0x00,0x48,0x7e,0x49,0x09,0x00,0x00,    // 0x66, f
 	166	 +  0x00,0x26,0x49,0x49,0x49,0x3f,0x01,0x00,    // 0x67, g
 	167	 +  0x41,0x7f,0x48,0x04,0x44,0x78,0x40,0x00,    // 0x68, h
 	168	 +  0x00,0x00,0x44,0x7d,0x40,0x00,0x00,0x00,    // 0x69, i
 	169	 +  0x00,0x00,0x40,0x44,0x3d,0x00,0x00,0x00,    // 0x6A, j
 	170	 +  0x41,0x7f,0x10,0x18,0x24,0x42,0x42,0x00,    // 0x6B, k
 	171	 +  0x00,0x40,0x41,0x7f,0x40,0x40,0x00,0x00,    // 0x6C, l
 	172	 +  0x42,0x7e,0x02,0x7c,0x02,0x7e,0x40,0x00,    // 0x6D, m
 	173	 +  0x42,0x7e,0x44,0x02,0x42,0x7c,0x40,0x00,    // 0x6E, n
 	174	 +  0x00,0x3c,0x42,0x42,0x42,0x3c,0x00,0x00,    // 0x6F, o
 	175	 +  0x00,0x41,0x7f,0x49,0x09,0x09,0x06,0x00,    // 0x70, p
 	176	 +  0x00,0x06,0x09,0x09,0x49,0x7f,0x41,0x00,    // 0x71, q
 	177	 +  0x00,0x42,0x7e,0x44,0x02,0x02,0x04,0x00,    // 0x72, r
 	178	 +  0x00,0x64,0x4a,0x4a,0x4a,0x36,0x00,0x00,    // 0x73, s
 	179	 +  0x00,0x04,0x3f,0x44,0x44,0x20,0x00,0x00,    // 0x73, t
 	180	 +  0x00,0x02,0x3e,0x40,0x40,0x22,0x7e,0x40,    // 0x75, u
 	181	 +  0x02,0x0e,0x32,0x40,0x32,0x0e,0x02,0x00,    // 0x76, v
 	182	 +  0x02,0x1e,0x62,0x18,0x62,0x1e,0x02,0x00,    // 0x77, w
 	183	 +  0x42,0x62,0x14,0x08,0x14,0x62,0x42,0x00,    // 0x78, x
 	184	 +  0x01,0x43,0x45,0x38,0x05,0x03,0x01,0x00,    // 0x79, y
 	185	 +  0x00,0x46,0x62,0x52,0x4a,0x46,0x62,0x00,    // 0x7A, z
 	186	 +  0x00,0x00,0x08,0x36,0x41,0x00,0x00,0x00,    // 0x7B, {
 	187	 +  0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0x00,    // 0x7C, |
 	188	 +  0x00,0x00,0x00,0x41,0x36,0x08,0x00,0x00,    // 0x7D, }
 	189	 +  0x00,0x18,0x08,0x08,0x10,0x10,0x18,0x00,    // 0x7E, ~
 	190	 +  0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55      // 0x7F, DEL
 	191	 +};
 	192	 +
 	193	 +/* ------------------------------------------------------------ */
 	194	 +
 	195	 +/************************************************************************/
 	196	 +
69 ????? lib/IOShieldOled/utility/FillPat.c View file @ 5a843cc
...	...	 @@ -0,0 +1,69 @@
 	1	 +
 	2	 +/************************************************************************/
 	3	 +/*                                    */
 	4	 +/*  FillPat.c  --  Pattern Table for Area Fill              */
 	5	 +/*                                    */
 	6	 +/************************************************************************/
 	7	 +/*  Author:   Gene Apperson                      */
 	8	 +/*  Copyright 2011, Digilent Inc.                    */
 	9	 +/************************************************************************/
 	10	 +/*
 	11	 +  This library is free software; you can redistribute it and/or
 	12	 +  modify it under the terms of the GNU Lesser General Public
 	13	 +  License as published by the Free Software Foundation; either
 	14	 +  version 2.1 of the License, or (at your option) any later version.
 	15	 +
 	16	 +  This library is distributed in the hope that it will be useful,
 	17	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	18	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	19	 +  Lesser General Public License for more details.
 	20	 +
 	21	 +  You should have received a copy of the GNU Lesser General Public
 	22	 +  License along with this library; if not, write to the Free Software
 	23	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	24	 +*/
 	25	 +/************************************************************************/
 	26	 +/*  Module Description:                         */
 	27	 +/*                                    */
 	28	 +/*  This module contains the data definitions for an set of8x8 pixel  */
 	29	 +/*  patterns used for area fill.                    */
 	30	 +/*                                    */
 	31	 +/*  This pattern table is defined for a display where each byte     */
 	32	 +/*  represents 8 vertical pixels and consecutive bytes give adjacent  */
 	33	 +/*  sets of 8 vertical pixels progressing to the right across the    */
 	34	 +/*  display. This is rotated 90 degrees from the conventional video    */
 	35	 +/*  display orientation.                        */
 	36	 +/*                                    */
 	37	 +/************************************************************************/
 	38	 +/*  Revision History:                          */
 	39	 +/*                                    */
 	40	 +/*  06/08/2011(GeneA): created                      */
 	41	 +/*                                    */
 	42	 +/************************************************************************/
 	43	 +
 	44	 +/* ------------------------------------------------------------ */
 	45	 +/*        Include File Definitions            */
 	46	 +/* ------------------------------------------------------------ */
 	47	 +
 	48	 +#include <p32xxxx.h>
 	49	 +#include <plib.h>
 	50	 +
 	51	 +/* ------------------------------------------------------------ */
 	52	 +/*        Global Variables                */
 	53	 +/* ------------------------------------------------------------ */
 	54	 +
 	55	 +const BYTE rgbFillPat[] = {
 	56	 +  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x00
 	57	 +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 0x01
 	58	 +  0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, // 0x02
 	59	 +  0x11, 0x44, 0x00, 0x11, 0x44, 0x00, 0x11, 0x44,  // 0x03
 	60	 +  0x92, 0x45, 0x24, 0x92, 0x45, 0x24, 0x92, 0x45,  // 0x04
 	61	 +  0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x92, // 0x05
 	62	 +  0x22, 0x11, 0x22, 0x00, 0x22, 0x11, 0x22, 0x00,  // 0x06
 	63	 +  0x11, 0x22, 0x11, 0x00, 0x11, 0x22, 0x11, 0x00  // 0x07
 	64	 +};
 	65	 +
 	66	 +/* ------------------------------------------------------------ */
 	67	 +
 	68	 +/************************************************************************/
 	69	 +
418 ????? lib/IOShieldOled/utility/OledChar.c View file @ 5a843cc
...	...	 @@ -0,0 +1,418 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  OledChar.c  --  Character Output Routines for OLED Display      */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:   Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  Module Description:                         */
 	26	 +/*                                    */
 	27	 +/*  This module contains the implementations of the 'character mode'  */
 	28	 +/*  functions. These functions treat the graphics display as a 4 row  */
 	29	 +/*  by 16 column character display.                    */
 	30	 +/*                                    */
 	31	 +/************************************************************************/
 	32	 +/*  Revision History:                          */
 	33	 +/*                                    */
 	34	 +/*  06/01/2011(GeneA): created                      */
 	35	 +/*                                    */
 	36	 +/************************************************************************/
 	37	 +
 	38	 +
 	39	 +/* ------------------------------------------------------------ */
 	40	 +/*        Include File Definitions            */
 	41	 +/* ------------------------------------------------------------ */
 	42	 +
 	43	 +#include <p32xxxx.h>
 	44	 +#include <plib.h>
 	45	 +
 	46	 +#include <inttypes.h>
 	47	 +
 	48	 +#include "OledDriver.h"
 	49	 +#include "OledChar.h"
 	50	 +#include "OledGrph.h"
 	51	 +
 	52	 +/* ------------------------------------------------------------ */
 	53	 +/*        Local Type Definitions              */
 	54	 +/* ------------------------------------------------------------ */
 	55	 +
 	56	 +
 	57	 +/* ------------------------------------------------------------ */
 	58	 +/*        Global Variables                */
 	59	 +/* ------------------------------------------------------------ */
 	60	 +
 	61	 +extern int    xcoOledCur;
 	62	 +extern int    ycoOledCur;
 	63	 +
 	64	 +extern BYTE *  pbOledCur;
 	65	 +extern BYTE    mskOledCur;
 	66	 +extern int    bnOledCur;
 	67	 +extern int    fOledCharUpdate;
 	68	 +
 	69	 +extern BYTE    rgbOledBmp[];
 	70	 +
 	71	 +extern int    dxcoOledFontCur;
 	72	 +extern int    dycoOledFontCur;
 	73	 +
 	74	 +extern  BYTE *  pbOledFontCur;
 	75	 +extern  BYTE *  pbOledFontUser;
 	76	 +
 	77	 +/* ------------------------------------------------------------ */
 	78	 +/*        Local Variables                  */
 	79	 +/* ------------------------------------------------------------ */
 	80	 +
 	81	 +int    xchOledCur;
 	82	 +int    ychOledCur;
 	83	 +
 	84	 +int    xchOledMax;
 	85	 +int    ychOledMax;
 	86	 +
 	87	 +BYTE *  pbOledFontExt;
 	88	 +
 	89	 +BYTE  rgbOledFontUser[cbOledFontUser];
 	90	 +
 	91	 +/* ------------------------------------------------------------ */
 	92	 +/*        Forward Declarations              */
 	93	 +/* ------------------------------------------------------------ */
 	94	 +
 	95	 +void  OledDrawGlyph(char ch);
 	96	 +void  OledAdvanceCursor();
 	97	 +
 	98	 +/* ------------------------------------------------------------ */
 	99	 +/*        Procedure Definitions              */
 	100	 +/* ------------------------------------------------------------ */
 	101	 +/***  OledSetCursor
 	102	 +**
 	103	 +**  Parameters:
 	104	 +**    xch      - horizontal character position
 	105	 +**    ych      - vertical character position
 	106	 +**
 	107	 +**  Return Value:
 	108	 +**    none
 	109	 +**
 	110	 +**  Errors:
 	111	 +**    none
 	112	 +**
 	113	 +**  Description:
 	114	 +**    Set the character cursor position to the specified location.
 	115	 +**    If either the specified X or Y location is off the display, it
 	116	 +**    is clamped to be on the display.
 	117	 +*/
 	118	 +
 	119	 +void
 	120	 +OledSetCursor(int xch, int ych)
 	121	 +  {
 	122	 +
 	123	 +  /* Clamp the specified location to the display surface
 	124	 +  */
 	125	 +  if (xch >= xchOledMax) {
 	126	 +    xch = xchOledMax-1;
 	127	 +  }
 	128	 +
 	129	 +  if (ych >= ychOledMax) {
 	130	 +    ych = ychOledMax-1;
 	131	 +  }
 	132	 +
 	133	 +  /* Save the given character location.
 	134	 +  */
 	135	 +  xchOledCur = xch;
 	136	 +  ychOledCur = ych;
 	137	 +
 	138	 +  /* Convert the character location to a frame buffer address.
 	139	 +  */
 	140	 +  OledMoveTo(xch*dxcoOledFontCur, ych*dycoOledFontCur);
 	141	 +
 	142	 +}
 	143	 +
 	144	 +/* ------------------------------------------------------------ */
 	145	 +/***  OledGetCursor
 	146	 +**
 	147	 +**  Parameters:
 	148	 +**    pxch    - pointer to variable to receive horizontal position
 	149	 +**    pych    - pointer to variable to receive vertical position
 	150	 +**
 	151	 +**  Return Value:
 	152	 +**    none
 	153	 +**
 	154	 +**  Errors:
 	155	 +**    none
 	156	 +**
 	157	 +**  Description:
 	158	 +**    Fetch the current cursor position
 	159	 +*/
 	160	 +
 	161	 +void
 	162	 +OledGetCursor( int * pxch, int * pych)
 	163	 +  {
 	164	 +
 	165	 +  *pxch = xchOledCur;
 	166	 +  *pych = ychOledCur;
 	167	 +
 	168	 +}
 	169	 +
 	170	 +/* ------------------------------------------------------------ */
 	171	 +/***  OledDefUserChar
 	172	 +**
 	173	 +**  Parameters:
 	174	 +**    ch    - character code to define
 	175	 +**    pbDef  - definition for the character
 	176	 +**
 	177	 +**  Return Value:
 	178	 +**    none
 	179	 +**
 	180	 +**  Errors:
 	181	 +**    Returns TRUE if successful, FALSE if not
 	182	 +**
 	183	 +**  Description:
 	184	 +**    Give a definition for the glyph for the specified user
 	185	 +**    character code. User definable character codes are in
 	186	 +**    the range 0x00 - 0x1F. If the code specified by ch is
 	187	 +**    outside this range, the function returns false.
 	188	 +*/
 	189	 +
 	190	 +int
 	191	 +OledDefUserChar(char ch, BYTE * pbDef)
 	192	 +  {
 	193	 +  BYTE *  pb;
 	194	 +  int    ib;
 	195	 +
 	196	 +  if (ch < chOledUserMax) {
 	197	 +    pb = pbOledFontUser + ch * cbOledChar;
 	198	 +    for (ib = 0; ib < cbOledChar; ib++) {
 	199	 +      *pb++ = *pbDef++;
 	200	 +    }
 	201	 +    return 1;
 	202	 +  }
 	203	 +  else {
 	204	 +    return 0;
 	205	 +  }
 	206	 +
 	207	 +  }
 	208	 +
 	209	 +/* ------------------------------------------------------------ */
 	210	 +/***  OledSetCharUpdate
 	211	 +**
 	212	 +**  Parameters:
 	213	 +**    f    - enable/disable automatic update
 	214	 +**
 	215	 +**  Return Value:
 	216	 +**    none
 	217	 +**
 	218	 +**  Errors:
 	219	 +**    none
 	220	 +**
 	221	 +**  Description:
 	222	 +**    Set the character update mode. This determines whether
 	223	 +**    or not the display is automatically updated after a
 	224	 +**    character or string is drawn. A non-zero value turns
 	225	 +**    automatic updating on.
 	226	 +*/
 	227	 +
 	228	 +void
 	229	 +OledSetCharUpdate(int f)
 	230	 +  {
 	231	 +
 	232	 +  fOledCharUpdate = (f != 0) ? 1 : 0;
 	233	 +
 	234	 +}
 	235	 +
 	236	 +/* ------------------------------------------------------------ */
 	237	 +/***  OledGetCharUpdate
 	238	 +**
 	239	 +**  Parameters:
 	240	 +**    none
 	241	 +**
 	242	 +**  Return Value:
 	243	 +**    returns current character update mode
 	244	 +**
 	245	 +**  Errors:
 	246	 +**    none
 	247	 +**
 	248	 +**  Description:
 	249	 +**    Return the current character update mode.
 	250	 +*/
 	251	 +
 	252	 +int
 	253	 +OledGetCharUpdate()
 	254	 +  {
 	255	 +
 	256	 +  return fOledCharUpdate;
 	257	 +
 	258	 +}
 	259	 +
 	260	 +/* ------------------------------------------------------------ */
 	261	 +/***  OledPutChar
 	262	 +**
 	263	 +**  Parameters:
 	264	 +**    ch      - character to write to display
 	265	 +**
 	266	 +**  Return Value:
 	267	 +**    none
 	268	 +**
 	269	 +**  Errors:
 	270	 +**    none
 	271	 +**
 	272	 +**  Description:
 	273	 +**    Write the specified character to the display at the current
 	274	 +**    cursor position and advance the cursor.
 	275	 +*/
 	276	 +
 	277	 +void
 	278	 +OledPutChar(char ch)
 	279	 +  {
 	280	 +
 	281	 +  OledDrawGlyph(ch);
 	282	 +  OledAdvanceCursor();
 	283	 +  if (fOledCharUpdate) {
 	284	 +    OledUpdate();
 	285	 +  }
 	286	 +
 	287	 +}
 	288	 +
 	289	 +/* ------------------------------------------------------------ */
 	290	 +/***  OledPutString
 	291	 +**
 	292	 +**  Parameters:
 	293	 +**    sz    - pointer to the null terminated string
 	294	 +**
 	295	 +**  Return Value:
 	296	 +**    none
 	297	 +**
 	298	 +**  Errors:
 	299	 +**    none
 	300	 +**
 	301	 +**  Description:
 	302	 +**    Write the specified null terminated character string to the
 	303	 +**    display and advance the cursor.
 	304	 +*/
 	305	 +
 	306	 +void
 	307	 +OledPutString(char * sz)
 	308	 +  {
 	309	 +
 	310	 +  while (*sz != '\0') {
 	311	 +    OledDrawGlyph(*sz);
 	312	 +    OledAdvanceCursor();
 	313	 +    sz += 1;
 	314	 +  }
 	315	 +
 	316	 +  if (fOledCharUpdate) {
 	317	 +    OledUpdate();
 	318	 +  }
 	319	 +
 	320	 +}
 	321	 +
 	322	 +/* ------------------------------------------------------------ */
 	323	 +/***  OledDrawGlyph
 	324	 +**
 	325	 +**  Parameters:
 	326	 +**    ch    - character code of character to draw
 	327	 +**
 	328	 +**  Return Value:
 	329	 +**    none
 	330	 +**
 	331	 +**  Errors:
 	332	 +**    none
 	333	 +**
 	334	 +**  Description:
 	335	 +**    Renders the specified character into the display buffer
 	336	 +**    at the current character cursor location. This does not
 	337	 +**    affect the current character cursor location or the 
 	338	 +**    current drawing position in the display buffer.
 	339	 +*/
 	340	 +
 	341	 +void
 	342	 +OledDrawGlyph(char ch)
 	343	 +  {
 	344	 +  BYTE *  pbFont;
 	345	 +  BYTE *  pbBmp;
 	346	 +  int    ib;
 	347	 +
 	348	 +  if ((ch & 0x80) != 0) {
 	349	 +    return;
 	350	 +  }
 	351	 +
 	352	 +  if (ch < chOledUserMax) {
 	353	 +    pbFont = pbOledFontUser + ch*cbOledChar;
 	354	 +  }
 	355	 +  else if ((ch & 0x80) == 0) {
 	356	 +    pbFont = pbOledFontCur + (ch-chOledUserMax) * cbOledChar;
 	357	 +  }
 	358	 +
 	359	 +  pbBmp = pbOledCur;
 	360	 +
 	361	 +  for (ib = 0; ib < dxcoOledFontCur; ib++) {
 	362	 +    *pbBmp++ = *pbFont++;
 	363	 +  }
 	364	 +
 	365	 +}
 	366	 +
 	367	 +/* ------------------------------------------------------------ */
 	368	 +/***  OledAdvanceCursor
 	369	 +**
 	370	 +**  Parameters:
 	371	 +**    none
 	372	 +**
 	373	 +**  Return Value:
 	374	 +**    none
 	375	 +**
 	376	 +**  Errors:
 	377	 +**    none
 	378	 +**
 	379	 +**  Description:
 	380	 +**    Advance the character cursor by one character location,
 	381	 +**    wrapping at the end of line and back to the top at the
 	382	 +**    end of the display.
 	383	 +*/
 	384	 +
 	385	 +void
 	386	 +OledAdvanceCursor()
 	387	 +  {
 	388	 +
 	389	 +  xchOledCur += 1;
 	390	 +  if (xchOledCur >= xchOledMax) {
 	391	 +    xchOledCur = 0;
 	392	 +    ychOledCur += 1;
 	393	 +  }
 	394	 +  if (ychOledCur >= ychOledMax) {
 	395	 +    ychOledCur = 0;
 	396	 +  }
 	397	 +
 	398	 +  OledSetCursor(xchOledCur, ychOledCur);
 	399	 +
 	400	 +}
 	401	 +
 	402	 +/* ------------------------------------------------------------ */
 	403	 +/***  ProcName
 	404	 +**
 	405	 +**  Parameters:
 	406	 +**
 	407	 +**  Return Value:
 	408	 +**
 	409	 +**  Errors:
 	410	 +**
 	411	 +**  Description:
 	412	 +**
 	413	 +*/
 	414	 +
 	415	 +/* ------------------------------------------------------------ */
 	416	 +
 	417	 +/************************************************************************/
 	418	 +
79 ????? lib/IOShieldOled/utility/OledChar.h View file @ 5a843cc
...	...	 @@ -0,0 +1,79 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  OledChar.h  --  Interface Declarations for OledChar.c        */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:    Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  File Description:                          */
 	26	 +/*                                    */
 	27	 +/*  Interface to OledChar.c                        */
 	28	 +/*                                    */
 	29	 +/************************************************************************/
 	30	 +/*  Revision History:                          */
 	31	 +/*                                    */
 	32	 +/*  06/01/2011(GeneA): created                      */
 	33	 +/*                                    */
 	34	 +/************************************************************************/
 	35	 +
 	36	 +#if !defined(OLEDCHAR_H)
 	37	 +#define OLEDCHAR_H
 	38	 +
 	39	 +/* ------------------------------------------------------------ */
 	40	 +/*          Miscellaneous Declarations          */
 	41	 +/* ------------------------------------------------------------ */
 	42	 +
 	43	 +
 	44	 +
 	45	 +/* ------------------------------------------------------------ */
 	46	 +/*          General Type Declarations          */
 	47	 +/* ------------------------------------------------------------ */
 	48	 +
 	49	 +
 	50	 +
 	51	 +/* ------------------------------------------------------------ */
 	52	 +/*          Object Class Declarations          */
 	53	 +/* ------------------------------------------------------------ */
 	54	 +
 	55	 +
 	56	 +
 	57	 +/* ------------------------------------------------------------ */
 	58	 +/*          Variable Declarations            */
 	59	 +/* ------------------------------------------------------------ */
 	60	 +
 	61	 +
 	62	 +
 	63	 +/* ------------------------------------------------------------ */
 	64	 +/*          Procedure Declarations            */
 	65	 +/* ------------------------------------------------------------ */
 	66	 +
 	67	 +void  OledSetCursor(int xch, int ych);
 	68	 +void  OledGetCursor(int * pxcy, int * pych);
 	69	 +int    OledDefUserChar(char ch, uint8_t * pbDef);
 	70	 +void  OledSetCharUpdate(int f);
 	71	 +int    OledGetCharUpdate();
 	72	 +void  OledPutChar(char ch);
 	73	 +void  OledPutString(char * sz);
 	74	 +
 	75	 +/* ------------------------------------------------------------ */
 	76	 +
 	77	 +#endif
 	78	 +
 	79	 +/************************************************************************/
782 ????? lib/IOShieldOled/utility/OledDriver.c View file @ 5a843cc
...	...	 @@ -0,0 +1,782 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  OledDriver.c  -- Graphics Driver Library for OLED Display      */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:   Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  Module Description:                         */
 	26	 +/*                                    */
 	27	 +/*  This is part of the device driver software for the OLED bit mapped  */
 	28	 +/*  display on the Digilent Basic I/O Shield. This module contains the  */
 	29	 +/*  initialization functions and basic display control functions.    */
 	30	 +/*                                    */
 	31	 +/************************************************************************/
 	32	 +/*  Revision History:                          */
 	33	 +/*                                    */
 	34	 +/*  04/29/2011(GeneA): Created                      */
 	35	 +/*  08/03/2011(GeneA): added functions to shut down the display and to  */
 	36	 +/*    turn the display on and off.                  */
 	37	 +/*  01/04/2012(GeneA): Changed use of DelayMs to using standard delay  */
 	38	 +/*    function. Removed delay.h                    */
 	39	 +/*                                    */
 	40	 +/************************************************************************/
 	41	 +
 	42	 +
 	43	 +/* ------------------------------------------------------------ */
 	44	 +/*        Include File Definitions            */
 	45	 +/* ------------------------------------------------------------ */
 	46	 +
 	47	 +#include <WProgram.h>
 	48	 +#include <p32xxxx.h>
 	49	 +#include <plib.h>
 	50	 +
 	51	 +#include "OledDriver.h"
 	52	 +#include "OledChar.h"
 	53	 +#include "OledGrph.h"
 	54	 +
 	55	 +/* ------------------------------------------------------------ */
 	56	 +/*        Local Symbol Definitions            */
 	57	 +/* ------------------------------------------------------------ */
 	58	 +
 	59	 +#define  cmdOledDisplayOn  0xAF
 	60	 +#define  cmdOledDisplayOff  0xAE
 	61	 +#define  cmdOledSegRemap    0xA1  //map column 127 to SEG0
 	62	 +#define  cmdOledComDir    0xC8  //scan from COM[N-1] to COM0
 	63	 +#define  cmdOledComConfig  0xDA  //set COM hardware configuration
 	64	 +
 	65	 +/* ------------------------------------------------------------ */
 	66	 +/*        Global Variables                */
 	67	 +/* ------------------------------------------------------------ */
 	68	 +
 	69	 +extern BYTE    rgbOledFont0[];
 	70	 +extern BYTE    rgbOledFontUser[];
 	71	 +extern BYTE    rgbFillPat[];
 	72	 +
 	73	 +extern int    xchOledMax;
 	74	 +extern int    ychOledMax;
 	75	 +
 	76	 +/* Coordinates of current pixel location on the display. The origin
 	77	 +** is at the upper left of the display. X increases to the right
 	78	 +** and y increases going down.
 	79	 +*/
 	80	 +int    xcoOledCur;
 	81	 +int    ycoOledCur;
 	82	 +
 	83	 +BYTE *  pbOledCur;      //address of byte corresponding to current location
 	84	 +int    bnOledCur;      //bit number of bit corresponding to current location
 	85	 +BYTE  clrOledCur;      //drawing color to use
 	86	 +BYTE *  pbOledPatCur;    //current fill pattern
 	87	 +int    fOledCharUpdate;
 	88	 +
 	89	 +int    dxcoOledFontCur;
 	90	 +int    dycoOledFontCur;
 	91	 +
 	92	 +BYTE *  pbOledFontCur;
 	93	 +BYTE *  pbOledFontUser;
 	94	 +
 	95	 +/* ------------------------------------------------------------ */
 	96	 +/*        Local Variables                  */
 	97	 +/* ------------------------------------------------------------ */
 	98	 +
 	99	 +/* This array is the offscreen frame buffer used for rendering.
 	100	 +** It isn't possible to read back frome the OLED display device,
 	101	 +** so display data is rendered into this offscreen buffer and then
 	102	 +** copied to the display.
 	103	 +*/
 	104	 +BYTE  rgbOledBmp[cbOledDispMax];
 	105	 +
 	106	 +/* ------------------------------------------------------------ */
 	107	 +/*        Forward Declarations              */
 	108	 +/* ------------------------------------------------------------ */
 	109	 +
 	110	 +void  OledHostInit();
 	111	 +void  OledHostTerm();
 	112	 +void  OledDevInit();
 	113	 +void  OledDevTerm();
 	114	 +void  OledDvrInit();
 	115	 +
 	116	 +void  OledPutBuffer(int cb, BYTE * rgbTx);
 	117	 +BYTE  Spi2PutByte(BYTE bVal);
 	118	 +
 	119	 +/* ------------------------------------------------------------ */
 	120	 +/*        Procedure Definitions              */
 	121	 +/* ------------------------------------------------------------ */
 	122	 +/***  OledInit
 	123	 +**
 	124	 +**  Parameters:
 	125	 +**    none
 	126	 +**
 	127	 +**  Return Value:
 	128	 +**    none
 	129	 +**
 	130	 +**  Errors:
 	131	 +**    none
 	132	 +**
 	133	 +**  Description:
 	134	 +**    Initialize the OLED display subsystem.
 	135	 +*/
 	136	 +
 	137	 +void
 	138	 +OledInit()
 	139	 +  {
 	140	 +
 	141	 +  /* Init the PIC32 peripherals used to talk to the display.
 	142	 +  */
 	143	 +  OledHostInit();
 	144	 +
 	145	 +  /* Init the memory variables used to control access to the
 	146	 +  ** display.
 	147	 +  */
 	148	 +  OledDvrInit();
 	149	 +
 	150	 +  /* Init the OLED display hardware.
 	151	 +  */
 	152	 +  OledDevInit();
 	153	 +
 	154	 +  /* Clear the display.
 	155	 +  */
 	156	 +  OledClear();
 	157	 +
 	158	 +}
 	159	 +
 	160	 +/* ------------------------------------------------------------ */
 	161	 +/***  OledTerm
 	162	 +**
 	163	 +**  Parameters:
 	164	 +**    none
 	165	 +**
 	166	 +**  Return Value:
 	167	 +**    none
 	168	 +**
 	169	 +**  Errors:
 	170	 +**    none
 	171	 +**
 	172	 +**  Description:
 	173	 +**    Shut down the OLED display.
 	174	 +*/
 	175	 +
 	176	 +void
 	177	 +OledTerm()
 	178	 +  {
 	179	 +
 	180	 +  /* Shut down the OLED display hardware.
 	181	 +  */
 	182	 +  OledDevTerm();
 	183	 +
 	184	 +  /* Release the PIC32 peripherals being used.
 	185	 +  */
 	186	 +  OledHostTerm();
 	187	 +
 	188	 +}
 	189	 +
 	190	 +/* ------------------------------------------------------------ */
 	191	 +/***  OledHostInit
 	192	 +**
 	193	 +**  Parameters:
 	194	 +**    none
 	195	 +**
 	196	 +**  Return Value:
 	197	 +**    none
 	198	 +**
 	199	 +**  Errors:
 	200	 +**    none
 	201	 +**
 	202	 +**  Description:
 	203	 +**    Perform PIC32 device initialization to prepare for use
 	204	 +**    of the OLED display.
 	205	 +**    This is currently hard coded for the Cerebot 32MX4 and
 	206	 +**    SPI2. This needs to be generalized.
 	207	 +*/
 	208	 +
 	209	 +void
 	210	 +OledHostInit()
 	211	 +  {
 	212	 +  #if defined (_BOARD_UNO_) || defined(_BOARD_UC32_)
 	213	 +    /* Initialize SPI port 2.
 	214	 +    */
 	215	 +    SPI2CON = 0;
 	216	 +    SPI2BRG = 4;        //8Mhz, with 80Mhz PB clock
 	217	 +    SPI2STATbits.SPIROV = 0;
 	218	 +    SPI2CONbits.CKP = 1;
 	219	 +    SPI2CONbits.MSTEN = 1;
 	220	 +    SPI2CONbits.ON = 1;
 	221	 +  #elif defined (_BOARD_MEGA_)
 	222	 +    /* Initialize pins for bit bang SPI. The Arduino Mega boards,
 	223	 +    ** and therefore the Max32 don't have the SPI port on the same
 	224	 +    ** connector pins as the Uno. The Basic I/O Shield doesn't even
 	225	 +    ** connect to the pins where the SPI port is located. So, for
 	226	 +    ** the Max32 board we need to do bit-banged SPI.
 	227	 +    */
 	228	 +    PORTSetBits(prtSck, bitSck);
 	229	 +    PORTSetBits(prtMosi, bitMosi);
 	230	 +    PORTSetPinsDigitalOut(prtSck, bitSck);
 	231	 +    PORTSetPinsDigitalOut(prtMosi, bitMosi);
 	232	 +  #else
 	233	 +    #error "No Supported Board Defined"  
 	234	 +  #endif
 	235	 +
 	236	 +  PORTSetBits(prtDataCmd, bitDataCmd);
 	237	 +  PORTSetBits(prtVddCtrl, bitVddCtrl);
 	238	 +  PORTSetBits(prtVbatCtrl, bitVbatCtrl);
 	239	 +
 	240	 +  PORTSetPinsDigitalOut(prtDataCmd, bitDataCmd);    //Data/Command# select
 	241	 +  PORTSetPinsDigitalOut(prtVddCtrl, bitVddCtrl);    //VDD power control (1=off)
 	242	 +  PORTSetPinsDigitalOut(prtVbatCtrl, bitVbatCtrl);  //VBAT power control (1=off)
 	243	 +
 	244	 +  /* Make the RG9 pin be an output. On the Basic I/O Shield, this pin
 	245	 +  ** is tied to reset.
 	246	 +  */
 	247	 +  PORTSetBits(prtReset, bitReset);
 	248	 +  PORTSetPinsDigitalOut(prtReset, bitReset);
 	249	 +
 	250	 +}
 	251	 +
 	252	 +/* ------------------------------------------------------------ */
 	253	 +/***  OledHostTerm
 	254	 +**
 	255	 +**  Parameters:
 	256	 +**    none
 	257	 +**
 	258	 +**  Return Value:
 	259	 +**    none
 	260	 +**
 	261	 +**  Errors:
 	262	 +**    none
 	263	 +**
 	264	 +**  Description:
 	265	 +**    Release processor resources used by the library
 	266	 +*/
 	267	 +
 	268	 +void
 	269	 +OledHostTerm()
 	270	 +  {
 	271	 +
 	272	 +  /* Make the Data/Command select, Reset, and SPI CS pins be inputs.
 	273	 +  */
 	274	 +  PORTSetBits(prtDataCmd, bitDataCmd);
 	275	 +  PORTSetPinsDigitalIn(prtDataCmd, bitDataCmd);    //Data/Command# select
 	276	 +  PORTSetBits(prtReset, bitReset);
 	277	 +  PORTSetPinsDigitalIn(prtReset, bitReset);
 	278	 +
 	279	 +  /* Make power control pins be inputs. The pullup resistors on the
 	280	 +  ** board will ensure that the power supplies stay off.
 	281	 +  */
 	282	 +  PORTSetBits(prtVddCtrl, bitVddCtrl);
 	283	 +  PORTSetBits(prtVbatCtrl, bitVbatCtrl);
 	284	 +  PORTSetPinsDigitalIn(prtVddCtrl, bitVddCtrl);    //VDD power control (1=off)
 	285	 +  PORTSetPinsDigitalIn(prtVbatCtrl, bitVbatCtrl);  //VBAT power control (1=off)
 	286	 +
 	287	 +  /* Turn SPI port 2 off.
 	288	 +  */
 	289	 +  #if defined (_BOARD_UNO_)
 	290	 +    SPI2CON = 0;
 	291	 +  #elif defined (_BOARD_MEGA_)
 	292	 +    PORTSetBits(prtSck, bitSck);
 	293	 +    PORTSetBits(prtMosi, bitMosi);
 	294	 +    PORTSetPinsDigitalIn(prtSck, bitSck);
 	295	 +    PORTSetPinsDigitalIn(prtMosi, bitMosi);
 	296	 +  #endif
 	297	 +}
 	298	 +
 	299	 +/* ------------------------------------------------------------ */
 	300	 +/***  OledDvrInit
 	301	 +**
 	302	 +**  Parameters:
 	303	 +**    none
 	304	 +**
 	305	 +**  Return Value:
 	306	 +**    none
 	307	 +**
 	308	 +**  Errors:
 	309	 +**    none
 	310	 +**
 	311	 +**  Description:
 	312	 +**    Initialize the OLED software system
 	313	 +*/
 	314	 +
 	315	 +void
 	316	 +OledDvrInit()
 	317	 +  {
 	318	 +  int    ib;
 	319	 +
 	320	 +  /* Init the parameters for the default font
 	321	 +  */
 	322	 +  dxcoOledFontCur = cbOledChar;
 	323	 +  dycoOledFontCur = 8;
 	324	 +  pbOledFontCur = rgbOledFont0;
 	325	 +  pbOledFontUser = rgbOledFontUser;
 	326	 +
 	327	 +  for (ib = 0; ib < cbOledFontUser; ib++) {
 	328	 +    rgbOledFontUser[ib] = 0;
 	329	 +  }
 	330	 +
 	331	 +  xchOledMax = ccolOledMax / dxcoOledFontCur;
 	332	 +  ychOledMax = crowOledMax / dycoOledFontCur;
 	333	 +
 	334	 +  /* Set the default character cursor position.
 	335	 +  */
 	336	 +  OledSetCursor(0, 0);
 	337	 +
 	338	 +  /* Set the default foreground draw color and fill pattern
 	339	 +  */
 	340	 +  clrOledCur = 0x01;
 	341	 +  pbOledPatCur = rgbFillPat;
 	342	 +  OledSetDrawMode(modOledSet);
 	343	 +
 	344	 +  /* Default the character routines to automaticall
 	345	 +  ** update the display.
 	346	 +  */
 	347	 +  fOledCharUpdate = 1;
 	348	 +
 	349	 +}
 	350	 +
 	351	 +/* ------------------------------------------------------------ */
 	352	 +/***  OledDevInit
 	353	 +**
 	354	 +**  Parameters:
 	355	 +**    none
 	356	 +**
 	357	 +**  Return Value:
 	358	 +**    none
 	359	 +**
 	360	 +**  Errors:
 	361	 +**    none
 	362	 +**
 	363	 +**  Description:
 	364	 +**    Initialize the OLED display controller and turn the display on.
 	365	 +*/
 	366	 +
 	367	 +void
 	368	 +OledDevInit()
 	369	 +  {
 	370	 +
 	371	 +  /* We're going to be sending commands, so clear the Data/Cmd bit
 	372	 +  */
 	373	 +  PORTClearBits(prtDataCmd, bitDataCmd);
 	374	 +
 	375	 +  /* Start by turning VDD on and wait a while for the power to come up.
 	376	 +  */
 	377	 +  PORTClearBits(prtVddCtrl, bitVddCtrl);
 	378	 +  delay(1);
 	379	 +
 	380	 +  /* Display off command
 	381	 +  */
 	382	 +  Spi2PutByte(cmdOledDisplayOff);
 	383	 +
 	384	 +  /* Bring Reset low and then high
 	385	 +  */
 	386	 +  PORTClearBits(prtReset, bitReset);
 	387	 +  delay(1);
 	388	 +  PORTSetBits(prtReset, bitReset);
 	389	 +
 	390	 +  /* Send the Set Charge Pump and Set Pre-Charge Period commands
 	391	 +  */
 	392	 +  Spi2PutByte(0x8D);    //From Univision data sheet, not in SSD1306 data sheet
 	393	 +  Spi2PutByte(0x14);
 	394	 +
 	395	 +  Spi2PutByte(0xD9);    //From Univision data sheet, not in SSD1306 data sheet
 	396	 +  Spi2PutByte(0xF1);
 	397	 +
 	398	 +  /* Turn on VCC and wait 100ms
 	399	 +  */
 	400	 +  PORTClearBits(prtVbatCtrl, bitVbatCtrl);
 	401	 +  delay(100);
 	402	 +
 	403	 +  /* Send the commands to invert the display.
 	404	 +  */
 	405	 +  Spi2PutByte(cmdOledSegRemap);    //remap columns
 	406	 +  Spi2PutByte(cmdOledComDir);      //remap the rows
 	407	 +
 	408	 +  /* Send the commands to select sequential COM configuration
 	409	 +  */
 	410	 +  Spi2PutByte(cmdOledComConfig);    //set COM configuration command
 	411	 +  Spi2PutByte(0x20);          //sequential COM, left/right remap enabled
 	412	 +
 	413	 +  /* Send Display On command
 	414	 +  */
 	415	 +  Spi2PutByte(cmdOledDisplayOn);
 	416	 +
 	417	 +}
 	418	 +
 	419	 +/* ------------------------------------------------------------ */
 	420	 +/***  OledDevTerm
 	421	 +**
 	422	 +**  Parameters:
 	423	 +**    none
 	424	 +**
 	425	 +**  Return Value:
 	426	 +**    none
 	427	 +**
 	428	 +**  Errors:
 	429	 +**    none
 	430	 +**
 	431	 +**  Description:
 	432	 +**    Shut down the OLED display hardware
 	433	 +*/
 	434	 +
 	435	 +void
 	436	 +OledDevTerm()
 	437	 +  {
 	438	 +
 	439	 +  /* Send the Display Off command.
 	440	 +  */
 	441	 +  Spi2PutByte(cmdOledDisplayOff);
 	442	 +
 	443	 +  /* Turn off VCC
 	444	 +  */
 	445	 +  PORTSetBits(prtVbatCtrl, bitVbatCtrl);
 	446	 +  delay(100);
 	447	 +
 	448	 +  /* Turn off VDD
 	449	 +  */
 	450	 +  PORTClearBits(prtVddCtrl, bitVddCtrl);
 	451	 +
 	452	 +}
 	453	 +
 	454	 +/* ------------------------------------------------------------ */
 	455	 +/***  OledDisplayOn
 	456	 +**
 	457	 +**  Parameters:
 	458	 +**    none
 	459	 +**
 	460	 +**  Return Value:
 	461	 +**    none
 	462	 +**
 	463	 +**  Errors:
 	464	 +**    none
 	465	 +**
 	466	 +**  Description:
 	467	 +**    Turn the display on. This assumes that the display has
 	468	 +**    already been powered on and initialized. All it does
 	469	 +**    is send the display on command.
 	470	 +*/
 	471	 +
 	472	 +void
 	473	 +OledDisplayOn()
 	474	 +  {
 	475	 +
 	476	 +  PORTClearBits(prtDataCmd, bitDataCmd);
 	477	 +  Spi2PutByte(cmdOledDisplayOn);
 	478	 +
 	479	 +}
 	480	 +
 	481	 +/* ------------------------------------------------------------ */
 	482	 +/***  OledDisplayOff
 	483	 +**
 	484	 +**  Parameters:
 	485	 +**    none
 	486	 +**
 	487	 +**  Return Value:
 	488	 +**    none
 	489	 +**
 	490	 +**  Errors:
 	491	 +**    none
 	492	 +**
 	493	 +**  Description:
 	494	 +**    Turn the display off. This does not power the display
 	495	 +**    down. All it does is send the display off command.
 	496	 +*/
 	497	 +
 	498	 +void
 	499	 +OledDisplayOff()
 	500	 +  {
 	501	 +
 	502	 +  PORTClearBits(prtDataCmd, bitDataCmd);
 	503	 +  Spi2PutByte(cmdOledDisplayOff);
 	504	 +
 	505	 +}
 	506	 +
 	507	 +/* ------------------------------------------------------------ */
 	508	 +/***  OledClear
 	509	 +**
 	510	 +**  Parameters:
 	511	 +**    none
 	512	 +**
 	513	 +**  Return Value:
 	514	 +**    none
 	515	 +**
 	516	 +**  Errors:
 	517	 +**    none
 	518	 +**
 	519	 +**  Description:
 	520	 +**    Clear the display. This clears the memory buffer and then
 	521	 +**    updates the display.
 	522	 +*/
 	523	 +
 	524	 +void
 	525	 +OledClear()
 	526	 +  {
 	527	 +
 	528	 +  OledClearBuffer();
 	529	 +  OledUpdate();
 	530	 +
 	531	 +}
 	532	 +
 	533	 +/* ------------------------------------------------------------ */
 	534	 +/***  OledClearBuffer
 	535	 +**
 	536	 +**  Parameters:
 	537	 +**    none
 	538	 +**
 	539	 +**  Return Value:
 	540	 +**    none
 	541	 +**
 	542	 +**  Errors:
 	543	 +**    none
 	544	 +**
 	545	 +**  Description:
 	546	 +**    Clear the display memory buffer.
 	547	 +*/
 	548	 +
 	549	 +void
 	550	 +OledClearBuffer()
 	551	 +  {
 	552	 +  int      ib;
 	553	 +  BYTE *    pb;
 	554	 +
 	555	 +  pb = rgbOledBmp;
 	556	 +
 	557	 +  /* Fill the memory buffer with 0.
 	558	 +  */
 	559	 +  for (ib = 0; ib < cbOledDispMax; ib++) {
 	560	 +    *pb++ = 0x00;
 	561	 +  }
 	562	 +
 	563	 +}
 	564	 +
 	565	 +/* ------------------------------------------------------------ */
 	566	 +/***  OledUpdate
 	567	 +**
 	568	 +**  Parameters:
 	569	 +**    none
 	570	 +**
 	571	 +**  Return Value:
 	572	 +**    none
 	573	 +**
 	574	 +**  Errors:
 	575	 +**    none
 	576	 +**
 	577	 +**  Description:
 	578	 +**    Update the OLED display with the contents of the memory buffer
 	579	 +*/
 	580	 +
 	581	 +void
 	582	 +OledUpdate()
 	583	 +  {
 	584	 +  int    ipag;
 	585	 +  int    icol;
 	586	 +  BYTE *  pb;
 	587	 +
 	588	 +  pb = rgbOledBmp;
 	589	 +
 	590	 +  for (ipag = 0; ipag < cpagOledMax; ipag++) {
 	591	 +
 	592	 +    PORTClearBits(prtDataCmd, bitDataCmd);
 	593	 +
 	594	 +    /* Set the page address
 	595	 +    */
 	596	 +    Spi2PutByte(0x22);    //Set page command
 	597	 +    Spi2PutByte(ipag);    //page number
 	598	 +
 	599	 +    /* Start at the left column
 	600	 +    */
 	601	 +    Spi2PutByte(0x00);    //set low nybble of column
 	602	 +    Spi2PutByte(0x10);    //set high nybble of column
 	603	 +
 	604	 +    PORTSetBits(prtDataCmd, bitDataCmd);
 	605	 +
 	606	 +    /* Copy this memory page of display data.
 	607	 +    */
 	608	 +    OledPutBuffer(ccolOledMax, pb);
 	609	 +    pb += ccolOledMax;
 	610	 +
 	611	 +  }
 	612	 +
 	613	 +}
 	614	 +
 	615	 +/* ------------------------------------------------------------ */
 	616	 +/***  OledPutBuffer
 	617	 +**
 	618	 +**  Parameters:
 	619	 +**    cb    - number of bytes to send/receive
 	620	 +**    rgbTx  - pointer to the buffer to send
 	621	 +**
 	622	 +**  Return Value:
 	623	 +**    none
 	624	 +**
 	625	 +**  Errors:
 	626	 +**    none
 	627	 +**
 	628	 +**  Description:
 	629	 +**    Send the bytes specified in rgbTx to the slave and return
 	630	 +**    the bytes read from the slave in rgbRx
 	631	 +*/
 	632	 +#if defined (_BOARD_UNO_) || defined(_BOARD_UC32_)
 	633	 +void
 	634	 +OledPutBuffer(int cb, BYTE * rgbTx)
 	635	 +  {
 	636	 +  int    ib;
 	637	 +  BYTE  bTmp;
 	638	 +
 	639	 +  /* Write/Read the data
 	640	 +  */
 	641	 +  for (ib = 0; ib < cb; ib++) {
 	642	 +    /* Wait for transmitter to be ready
 	643	 +    */
 	644	 +    while (SPI2STATbits.SPITBE == 0);
 	645	 +
 	646	 +    /* Write the next transmit byte.
 	647	 +    */
 	648	 +    SPI2BUF = *rgbTx++;
 	649	 +
 	650	 +    /* Wait for receive byte.
 	651	 +    */
 	652	 +    while (SPI2STATbits.SPIRBF == 0);
 	653	 +    bTmp = SPI2BUF;
 	654	 +
 	655	 +  }
 	656	 +
 	657	 +}
 	658	 +#elif defined (_BOARD_MEGA_)
 	659	 +void
 	660	 +OledPutBuffer(int cb, BYTE * rgbTx)
 	661	 +  {
 	662	 +  int    ib;
 	663	 +  int    bit;
 	664	 +  BYTE  bVal;
 	665	 +
 	666	 +  for(ib = 0; ib < cb; ib++) {  
 	667	 +
 	668	 +    bVal = *rgbTx++;
 	669	 +
 	670	 +    for(bit = 0; bit < 8;  bit++) {
 	671	 +      /* Check if MSB is 1 or 0 and set MOSI pin accordingly
 	672	 +      */
 	673	 +      if(bVal & 0x80)
 	674	 +        PORTSetBits(prtMosi, bitMosi);
 	675	 +      else
 	676	 +        PORTClearBits(prtMosi, bitMosi);
 	677	 +
 	678	 +      /* Lower the clock line
 	679	 +      */
 	680	 +      PORTClearBits(prtSck, bitSck);
 	681	 +
 	682	 +      /* Shift byte being sent to the left by 1
 	683	 +      */
 	684	 +      bVal <<= 1;
 	685	 +
 	686	 +      /* Raise the clock line
 	687	 +      */
 	688	 +      PORTSetBits(prtSck, bitSck);
 	689	 +    }
 	690	 +  }
 	691	 +}
 	692	 +#endif
 	693	 +
 	694	 +/* ------------------------------------------------------------ */
 	695	 +/***  Spi2PutByte
 	696	 +**
 	697	 +**  Parameters:
 	698	 +**    bVal    - byte value to write
 	699	 +**
 	700	 +**  Return Value:
 	701	 +**    Returns byte read
 	702	 +**
 	703	 +**  Errors:
 	704	 +**    none
 	705	 +**
 	706	 +**  Description:
 	707	 +**    Write/Read a byte on SPI port 2
 	708	 +*/
 	709	 +#if defined (_BOARD_UNO_) || defined(_BOARD_UC32_)
 	710	 +BYTE
 	711	 +Spi2PutByte(BYTE bVal)
 	712	 +  {
 	713	 +  BYTE  bRx;
 	714	 +
 	715	 +  /* Wait for transmitter to be ready
 	716	 +  */
 	717	 +  while (SPI2STATbits.SPITBE == 0);
 	718	 +
 	719	 +  /* Write the next transmit byte.
 	720	 +  */
 	721	 +  SPI2BUF = bVal;
 	722	 +
 	723	 +  /* Wait for receive byte.
 	724	 +  */
 	725	 +  while (SPI2STATbits.SPIRBF == 0);
 	726	 +
 	727	 +  /* Put the received byte in the buffer.
 	728	 +  */
 	729	 +  bRx = SPI2BUF;
 	730	 +  
 	731	 +  return bRx;
 	732	 +
 	733	 +}
 	734	 +#elif defined (_BOARD_MEGA_)
 	735	 +BYTE
 	736	 +Spi2PutByte(BYTE bVal)
 	737	 +  {
 	738	 +  int    bit;
 	739	 +  BYTE  bRx;
 	740	 +
 	741	 +  for(bit = 0; bit < 8;  bit++) {
 	742	 +    /* Check if MSB is 1 or 0 and set MOSI pin accordingly
 	743	 +    */
 	744	 +    if(bVal & 0x80)
 	745	 +      PORTSetBits(prtMosi, bitMosi);
 	746	 +    else
 	747	 +      PORTClearBits(prtMosi, bitMosi);
 	748	 +
 	749	 +    /* Lower the clock line
 	750	 +    */
 	751	 +    PORTClearBits(prtSck, bitSck);
 	752	 +
 	753	 +    /* Shift byte being sent to the left by 1
 	754	 +    */
 	755	 +    bVal <<= 1;
 	756	 +
 	757	 +    /* Raise the clock line
 	758	 +    */
 	759	 +    PORTSetBits(prtSck, bitSck);
 	760	 +  }
 	761	 +
 	762	 +  return bRx;
 	763	 +}
 	764	 +#endif
 	765	 +
 	766	 +/* ------------------------------------------------------------ */
 	767	 +/***  ProcName
 	768	 +**
 	769	 +**  Parameters:
 	770	 +**
 	771	 +**  Return Value:
 	772	 +**
 	773	 +**  Errors:
 	774	 +**
 	775	 +**  Description:
 	776	 +**
 	777	 +*/
 	778	 +
 	779	 +/* ------------------------------------------------------------ */
 	780	 +
 	781	 +/************************************************************************/
 	782	 +
126 ????? lib/IOShieldOled/utility/OledDriver.h View file @ 5a843cc
...	...	 @@ -0,0 +1,126 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  OledDriver.h -- Interface Declarations for OLED Display Driver     */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:    Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  File Description:                          */
 	26	 +/*                                    */
 	27	 +/*  Interface to OledDriver.c                      */
 	28	 +/*                                    */
 	29	 +/************************************************************************/
 	30	 +/*  Revision History:                          */
 	31	 +/*                                    */
 	32	 +/*  04/29/2011(GeneA): created                      */
 	33	 +/*                                    */
 	34	 +/************************************************************************/
 	35	 +
 	36	 +#if !defined(OLEDDRIVER_INC)
 	37	 +#define  OLEDDRIVER_INC
 	38	 +
 	39	 +/* ------------------------------------------------------------ */
 	40	 +/*          Miscellaneous Declarations          */
 	41	 +/* ------------------------------------------------------------ */
 	42	 +
 	43	 +#define  cbOledDispMax  512    //max number of bytes in display buffer
 	44	 +
 	45	 +#define  ccolOledMax    128    //number of display columns
 	46	 +#define  crowOledMax    32    //number of display rows
 	47	 +#define  cpagOledMax    4    //number of display memory pages
 	48	 +
 	49	 +#define  cbOledChar    8    //font glyph definitions is 8 bytes long
 	50	 +#define  chOledUserMax  0x20  //number of character defs in user font table
 	51	 +#define  cbOledFontUser  (chOledUserMax*cbOledChar)
 	52	 +
 	53	 +/* Graphics drawing modes.
 	54	 +*/
 	55	 +#define  modOledSet    0
 	56	 +#define  modOledOr    1
 	57	 +#define  modOledAnd    2
 	58	 +#define  modOledXor    3
 	59	 +
 	60	 +/* ------------------------------------------------------------ */
 	61	 +/*          General Type Declarations          */
 	62	 +/* ------------------------------------------------------------ */
 	63	 +
 	64	 +/* Pin definitions for access to OLED control signals on ChipKitUno and ChipKitMax
 	65	 +*/
 	66	 +#if defined (_BOARD_UNO_) || defined(_BOARD_UC32_)
 	67	 +  #define  prtVddCtrl  IOPORT_F
 	68	 +  #define  prtVbatCtrl IOPORT_F
 	69	 +  #define  prtDataCmd  IOPORT_F
 	70	 +  #define  prtReset  IOPORT_G
 	71	 +
 	72	 +  #define  bitVddCtrl  BIT_6
 	73	 +  #define  bitVbatCtrl  BIT_5
 	74	 +  #define bitDataCmd  BIT_4
 	75	 +  #define  bitReset  BIT_9
 	76	 +#elif defined (_BOARD_MEGA_)
 	77	 +  #define prtMosi    IOPORT_C
 	78	 +  #define prtMiso    IOPORT_A
 	79	 +  #define prtSck    IOPORT_A
 	80	 +
 	81	 +  #define  prtVddCtrl  IOPORT_G
 	82	 +  #define  prtVbatCtrl IOPORT_G
 	83	 +  #define  prtDataCmd  IOPORT_G
 	84	 +  #define  prtReset  IOPORT_D
 	85	 +
 	86	 +  #define bitMosi    BIT_4
 	87	 +  #define bitMiso    BIT_2
 	88	 +  #define bitSck    BIT_3
 	89	 +
 	90	 +  #define  bitVddCtrl  BIT_14
 	91	 +  #define  bitVbatCtrl  BIT_13
 	92	 +  #define bitDataCmd  BIT_12
 	93	 +  #define  bitReset  BIT_4
 	94	 +#endif
 	95	 +
 	96	 +
 	97	 +
 	98	 +/* ------------------------------------------------------------ */
 	99	 +/*          Object Class Declarations          */
 	100	 +/* ------------------------------------------------------------ */
 	101	 +
 	102	 +
 	103	 +
 	104	 +/* ------------------------------------------------------------ */
 	105	 +/*          Variable Declarations            */
 	106	 +/* ------------------------------------------------------------ */
 	107	 +
 	108	 +
 	109	 +
 	110	 +/* ------------------------------------------------------------ */
 	111	 +/*          Procedure Declarations            */
 	112	 +/* ------------------------------------------------------------ */
 	113	 +
 	114	 +void  OledInit();
 	115	 +void  OledTerm();
 	116	 +void  OledDisplayOn();
 	117	 +void  OledDisplayOff();
 	118	 +void  OledClear();
 	119	 +void  OledClearBuffer();
 	120	 +void  OledUpdate();
 	121	 +
 	122	 +/* ------------------------------------------------------------ */
 	123	 +
 	124	 +#endif
 	125	 +
 	126	 +/************************************************************************/
1,193 ????? lib/IOShieldOled/utility/OledGrph.c View file @ 5a843cc
...	...	 @@ -0,0 +1,1193 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  OledGrph.c  --  OLED Display Graphics Routines            */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:   Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  Module Description:                         */
 	26	 +/*                                    */
 	27	 +/*  This module contains the implementation of the graphics functions  */
 	28	 +/*  for the OLED display driver.                    */
 	29	 +/*                                    */
 	30	 +/************************************************************************/
 	31	 +/*  Revision History:                          */
 	32	 +/*                                    */
 	33	 +/*  06/03/2011(GeneA): created                      */
 	34	 +/*                                    */
 	35	 +/************************************************************************/
 	36	 +
 	37	 +
 	38	 +/* ------------------------------------------------------------ */
 	39	 +/*        Include File Definitions            */
 	40	 +/* ------------------------------------------------------------ */
 	41	 +
 	42	 +#include <p32xxxx.h>
 	43	 +#include <plib.h>
 	44	 +
 	45	 +#include "OledDriver.h"
 	46	 +
 	47	 +/* ------------------------------------------------------------ */
 	48	 +/*        Local Type Definitions              */
 	49	 +/* ------------------------------------------------------------ */
 	50	 +
 	51	 +
 	52	 +/* ------------------------------------------------------------ */
 	53	 +/*        Global Variables                */
 	54	 +/* ------------------------------------------------------------ */
 	55	 +
 	56	 +extern int    xcoOledCur;
 	57	 +extern int    ycoOledCur;
 	58	 +extern BYTE *  pbOledCur;
 	59	 +extern BYTE    rgbOledBmp[];
 	60	 +extern BYTE    rgbFillPat[];
 	61	 +extern int    bnOledCur;
 	62	 +extern BYTE    clrOledCur;
 	63	 +extern BYTE *  pbOledPatCur;
 	64	 +extern BYTE  *  pbOledFontUser;
 	65	 +extern BYTE *  pbOledFontCur;
 	66	 +extern int    dxcoOledFontCur;
 	67	 +extern int    dycoOledFontCur;
 	68	 +
 	69	 +/* ------------------------------------------------------------ */
 	70	 +/*        Local Variables                  */
 	71	 +/* ------------------------------------------------------------ */
 	72	 +
 	73	 +BYTE  (*pfnDoRop)(BYTE bPix, BYTE bDsp, BYTE mskPix);
 	74	 +int    modOledCur;
 	75	 +
 	76	 +/* ------------------------------------------------------------ */
 	77	 +/*        Forward Declarations              */
 	78	 +/* ------------------------------------------------------------ */
 	79	 +
 	80	 +void  OledMoveDown();
 	81	 +void  OledMoveUp();
 	82	 +void  OledMoveRight();
 	83	 +void  OledMoveLeft();
 	84	 +BYTE  OledRopSet(BYTE bPix, BYTE bDsp, BYTE mskPix);
 	85	 +BYTE  OledRopOr(BYTE bPix, BYTE bDsp, BYTE mskPix);
 	86	 +BYTE  OledRopAnd(BYTE bPix, BYTE bDsp, BYTE mskPix);
 	87	 +BYTE  OledRopXor(BYTE bPix, BYTE bDsp, BYTE mskPix);
 	88	 +int    OledClampXco(int xco);
 	89	 +int    OledClampYco(int yco);
 	90	 +
 	91	 +/* ------------------------------------------------------------ */
 	92	 +/*        Procedure Definitions              */
 	93	 +/* ------------------------------------------------------------ */
 	94	 +/***  OledMoveTo
 	95	 +**
 	96	 +**  Parameters:
 	97	 +**    xco      - x coordinate
 	98	 +**    yco      - y coordinate
 	99	 +**
 	100	 +**  Return Value:
 	101	 +**    none
 	102	 +**
 	103	 +**  Errors:
 	104	 +**    none
 	105	 +**
 	106	 +**  Description:
 	107	 +**    Set the current graphics drawing position.
 	108	 +*/
 	109	 +
 	110	 +void
 	111	 +OledMoveTo(int xco, int yco)
 	112	 +  {
 	113	 +
 	114	 +  /* Clamp the specified coordinates to the display surface
 	115	 +  */
 	116	 +  xco = OledClampXco(xco);
 	117	 +  yco = OledClampYco(yco);
 	118	 +
 	119	 +  /* Save the current position.
 	120	 +  */
 	121	 +  xcoOledCur = xco;
 	122	 +  ycoOledCur = yco;
 	123	 +
 	124	 +  /* Compute the display access parameters corresponding to
 	125	 +  ** the specified position.
 	126	 +  */
 	127	 +  pbOledCur = &rgbOledBmp[((yco/8) * ccolOledMax) + xco];
 	128	 +  bnOledCur = yco & 7;
 	129	 +
 	130	 +}
 	131	 +
 	132	 +/* ------------------------------------------------------------ */
 	133	 +/***  OledGetPos
 	134	 +**
 	135	 +**  Parameters:
 	136	 +**    pxco  - variable to receive x coordinate
 	137	 +**    pyco  - variable to receive y coordinate
 	138	 +**
 	139	 +**  Return Value:
 	140	 +**    none
 	141	 +**
 	142	 +**  Errors:
 	143	 +**    none
 	144	 +**
 	145	 +**  Description:
 	146	 +**    Fetch the current graphics drawing position
 	147	 +*/
 	148	 +
 	149	 +void
 	150	 +OledGetPos(int * pxco, int * pyco)
 	151	 +  {
 	152	 +
 	153	 +  *pxco = xcoOledCur;
 	154	 +  *pyco = ycoOledCur;
 	155	 +
 	156	 +}
 	157	 +
 	158	 +/* ------------------------------------------------------------ */
 	159	 +/***  OledSetDrawColor
 	160	 +**
 	161	 +**  Parameters:
 	162	 +**    clr    - drawing color to set
 	163	 +**
 	164	 +**  Return Value:
 	165	 +**    none
 	166	 +**
 	167	 +**  Errors:
 	168	 +**    none
 	169	 +**
 	170	 +**  Description:
 	171	 +**    Set the foreground color used for pixel draw operations.
 	172	 +*/
 	173	 +
 	174	 +void
 	175	 +OledSetDrawColor(BYTE clr)
 	176	 +  {
 	177	 +
 	178	 +  clrOledCur = clr & 0x01;
 	179	 +
 	180	 +}
 	181	 +
 	182	 +/* ------------------------------------------------------------ */
 	183	 +/***  OledGetStdPattern
 	184	 +**
 	185	 +**  Parameters:
 	186	 +**    ipat    - index to standard fill pattern
 	187	 +**
 	188	 +**  Return Value:
 	189	 +**    returns a pointer to the standard fill pattern
 	190	 +**
 	191	 +**  Errors:
 	192	 +**    returns pattern 0 if index out of range
 	193	 +**
 	194	 +**  Description:
 	195	 +**    Return a pointer to the byte array for the specified
 	196	 +**    standard fill pattern.
 	197	 +*/
 	198	 +
 	199	 +BYTE *
 	200	 +OledGetStdPattern(int ipat)
 	201	 +  {
 	202	 +
 	203	 +  return rgbFillPat + 8*ipat;
 	204	 +
 	205	 +}
 	206	 +
 	207	 +/* ------------------------------------------------------------ */
 	208	 +/***  OledSetFillPattern
 	209	 +**
 	210	 +**  Parameters:
 	211	 +**    pbPat  - pointer to the fill pattern
 	212	 +**
 	213	 +**  Return Value:
 	214	 +**    none
 	215	 +**
 	216	 +**  Errors:
 	217	 +**    none
 	218	 +**
 	219	 +**  Description:
 	220	 +**    Set a pointer to the current fill pattern to use. A fill
 	221	 +**    pattern is an array of 8 bytes.
 	222	 +*/
 	223	 +
 	224	 +void
 	225	 +OledSetFillPattern(BYTE * pbPat)
 	226	 +  {
 	227	 +
 	228	 +  pbOledPatCur = pbPat;
 	229	 +
 	230	 +}
 	231	 +
 	232	 +/* ------------------------------------------------------------ */
 	233	 +/***  OledSetDrawMode
 	234	 +**
 	235	 +**  Parameters:
 	236	 +**    mod    - drawing mode to select
 	237	 +**
 	238	 +**  Return Value:
 	239	 +**    none
 	240	 +**
 	241	 +**  Errors:
 	242	 +**    none
 	243	 +**
 	244	 +**  Description:
 	245	 +**    Set the specified mode as the current drawing mode.
 	246	 +*/
 	247	 +
 	248	 +void
 	249	 +OledSetDrawMode(int mod)
 	250	 +  {
 	251	 +
 	252	 +  modOledCur = mod;
 	253	 +
 	254	 +  switch(mod) {
 	255	 +    case  modOledSet:
 	256	 +      pfnDoRop = OledRopSet;
 	257	 +      break;
 	258	 +
 	259	 +    case  modOledOr:
 	260	 +      pfnDoRop = OledRopOr;
 	261	 +      break;
 	262	 +
 	263	 +    case  modOledAnd:
 	264	 +      pfnDoRop = OledRopAnd;
 	265	 +      break;
 	266	 +
 	267	 +    case  modOledXor:
 	268	 +      pfnDoRop = OledRopXor;
 	269	 +      break;
 	270	 +
 	271	 +    default:
 	272	 +      modOledCur = modOledSet;
 	273	 +      pfnDoRop = OledRopSet;
 	274	 +  }
 	275	 +
 	276	 +}
 	277	 +
 	278	 +/* ------------------------------------------------------------ */
 	279	 +/***  OledGetDrawMode
 	280	 +**
 	281	 +**  Parameters:
 	282	 +**    none
 	283	 +
 	284	 +**  Return Value:
 	285	 +**    returns current drawing mode
 	286	 +**
 	287	 +**  Errors:
 	288	 +**    none
 	289	 +**
 	290	 +**  Description:
 	291	 +**    Get the current drawing mode
 	292	 +*/
 	293	 +
 	294	 +int
 	295	 +OledGetDrawMode()
 	296	 +  {
 	297	 +
 	298	 +  return modOledCur;
 	299	 +
 	300	 +}
 	301	 +
 	302	 +/* ------------------------------------------------------------ */
 	303	 +/***  OledDrawPixel
 	304	 +**
 	305	 +**  Parameters:
 	306	 +**    none
 	307	 +**
 	308	 +**  Return Value:
 	309	 +**    none
 	310	 +**
 	311	 +**  Errors:
 	312	 +**    none
 	313	 +**
 	314	 +**  Description:
 	315	 +**    Set the pixel at the current drawing location to the
 	316	 +**    specified value.
 	317	 +*/
 	318	 +
 	319	 +void
 	320	 +OledDrawPixel()
 	321	 +  {
 	322	 +
 	323	 +  *pbOledCur = (*pfnDoRop)((clrOledCur << bnOledCur), *pbOledCur, (1<<bnOledCur));
 	324	 +
 	325	 +}
 	326	 +
 	327	 +/* ------------------------------------------------------------ */
 	328	 +/***  OledGetPixel
 	329	 +**
 	330	 +**  Parameters:
 	331	 +**    none
 	332	 +**
 	333	 +**  Return Value:
 	334	 +**    returns pixel value at current drawing location
 	335	 +**
 	336	 +**  Errors:
 	337	 +**    none
 	338	 +**
 	339	 +**  Description:
 	340	 +**    Return the value of the pixel at the current drawing location
 	341	 +*/
 	342	 +
 	343	 +BYTE
 	344	 +OledGetPixel()
 	345	 +  {
 	346	 +
 	347	 +  return (*pbOledCur & (1<<bnOledCur)) != 0 ? 1 : 0;
 	348	 +
 	349	 +}
 	350	 +
 	351	 +/* ------------------------------------------------------------ */
 	352	 +/***  OledLineTo
 	353	 +**
 	354	 +**  Parameters:
 	355	 +**    xco      - x coordinate
 	356	 +**    yco      - y coordinate
 	357	 +**
 	358	 +**  Return Value:
 	359	 +**    none
 	360	 +**
 	361	 +**  Errors:
 	362	 +**    none
 	363	 +**
 	364	 +**  Description:
 	365	 +**    Draw a line from the current position to the specified
 	366	 +**    position.
 	367	 +*/
 	368	 +
 	369	 +void
 	370	 +OledLineTo(int xco, int yco)
 	371	 +  {
 	372	 +  int    err;
 	373	 +  int    del;
 	374	 +  int    lim;
 	375	 +  int    cpx;
 	376	 +  int    dxco;
 	377	 +  int    dyco;
 	378	 +  void  (*pfnMajor)();
 	379	 +  void  (*pfnMinor)();
 	380	 +
 	381	 +  /* Clamp the point to be on the display.
 	382	 +  */
 	383	 +  xco = OledClampXco(xco);
 	384	 +  yco = OledClampYco(yco);
 	385	 +
 	386	 +  /* Determine which octant the line occupies
 	387	 +  */
 	388	 +  dxco = xco - xcoOledCur;
 	389	 +  dyco = yco - ycoOledCur;
 	390	 +  if (abs(dxco) >= abs(dyco)) {
 	391	 +    /* Line is x-major
 	392	 +    */
 	393	 +    lim = abs(dxco);
 	394	 +    del = abs(dyco);
 	395	 +    if (dxco >= 0) {
 	396	 +      pfnMajor = OledMoveRight;
 	397	 +    }
 	398	 +    else {
 	399	 +      pfnMajor = OledMoveLeft;
 	400	 +    }
 	401	 +
 	402	 +    if (dyco >= 0) {
 	403	 +      pfnMinor = OledMoveDown;
 	404	 +    }
 	405	 +    else {
 	406	 +      pfnMinor = OledMoveUp;
 	407	 +    }
 	408	 +  }
 	409	 +  else {
 	410	 +    /* Line is y-major
 	411	 +    */
 	412	 +    lim = abs(dyco);
 	413	 +    del = abs(dxco);
 	414	 +    if (dyco >= 0) {
 	415	 +      pfnMajor = OledMoveDown;
 	416	 +    }
 	417	 +    else {
 	418	 +      pfnMajor = OledMoveUp;
 	419	 +    }
 	420	 +
 	421	 +    if (dxco >= 0) {
 	422	 +      pfnMinor = OledMoveRight;
 	423	 +    }
 	424	 +    else {
 	425	 +      pfnMinor = OledMoveLeft;
 	426	 +    }
 	427	 +  }
 	428	 +
 	429	 +  /* Render the line. The algorithm is:
 	430	 +  **    Write the current pixel
 	431	 +  **    Move one pixel on the major axis
 	432	 +  **    Add the minor axis delta to the error accumulator
 	433	 +  **    if the error accumulator is greater than the major axis delta
 	434	 +  **      Move one pixel in the minor axis
 	435	 +  **      Subtract major axis delta from error accumulator
 	436	 +  */
 	437	 +  err = lim/2;
 	438	 +  cpx = lim;
 	439	 +  while (cpx > 0) {
 	440	 +    OledDrawPixel();
 	441	 +    (*pfnMajor)();
 	442	 +    err += del;
 	443	 +    if (err > lim) {
 	444	 +      err -= lim;
 	445	 +      (*pfnMinor)();
 	446	 +    }
 	447	 +    cpx -= 1;
 	448	 +  }
 	449	 +
 	450	 +  /* Update the current location variables.
 	451	 +  */
 	452	 +  xcoOledCur = xco;
 	453	 +  ycoOledCur = yco;    
 	454	 +
 	455	 +}
 	456	 +
 	457	 +/* ------------------------------------------------------------ */
 	458	 +/***  OledDrawRect
 	459	 +**
 	460	 +**  Parameters:
 	461	 +**    xco    - x coordinate of other corner
 	462	 +**    yco    - y coordinate of other corner
 	463	 +**
 	464	 +**  Return Value:
 	465	 +**    none
 	466	 +**
 	467	 +**  Errors:
 	468	 +**    none
 	469	 +**
 	470	 +**  Description:
 	471	 +**    Draw a rectangle bounded by the current location and
 	472	 +**    the specified location.
 	473	 +*/
 	474	 +
 	475	 +void
 	476	 +OledDrawRect(int xco, int yco)
 	477	 +  {
 	478	 +  int    xco1;
 	479	 +  int    yco1;
 	480	 +
 	481	 +  /* Clamp the point to be on the display.
 	482	 +  */
 	483	 +  xco = OledClampXco(xco);
 	484	 +  yco = OledClampYco(yco);
 	485	 +
 	486	 +  xco1 = xcoOledCur;
 	487	 +  yco1 = ycoOledCur;
 	488	 +  OledLineTo(xco, yco1);
 	489	 +  OledLineTo(xco, yco);
 	490	 +  OledLineTo(xco1, yco);
 	491	 +  OledLineTo(xco1, yco1);
 	492	 +}
 	493	 +
 	494	 +/* ------------------------------------------------------------ */
 	495	 +/***  OledFillRect
 	496	 +**
 	497	 +**  Parameters:
 	498	 +**    xco    - x coordinate of other corner
 	499	 +**    yco    - y coordinate of other corner
 	500	 +**
 	501	 +**  Return Value:
 	502	 +**    none
 	503	 +**
 	504	 +**  Errors:
 	505	 +**    none
 	506	 +**
 	507	 +**  Description:
 	508	 +**    Fill a rectangle bounded by the current location and
 	509	 +**    the specified location.
 	510	 +*/
 	511	 +
 	512	 +void
 	513	 +OledFillRect(int xco, int yco)
 	514	 +  {
 	515	 +  int    xcoLeft;
 	516	 +  int    xcoRight;
 	517	 +  int    ycoTop;
 	518	 +  int    ycoBottom;
 	519	 +  int    ibPat;
 	520	 +  BYTE *  pbCur;
 	521	 +  BYTE *  pbLeft;
 	522	 +  int    xcoCur;
 	523	 +  BYTE  bTmp;
 	524	 +  BYTE  mskPat;
 	525	 +
 	526	 +  /* Clamp the point to be on the display.
 	527	 +  */
 	528	 +  xco = OledClampXco(xco);
 	529	 +  yco = OledClampYco(yco);
 	530	 +
 	531	 +  /* Set up the four sides of the rectangle.
 	532	 +  */
 	533	 +  if (xcoOledCur < xco) {
 	534	 +    xcoLeft = xcoOledCur;
 	535	 +    xcoRight = xco;
 	536	 +  }
 	537	 +  else {
 	538	 +    xcoLeft = xco;
 	539	 +    xcoRight = xcoOledCur;
 	540	 +  }
 	541	 +
 	542	 +  if (ycoOledCur < yco) {
 	543	 +    ycoTop = ycoOledCur;
 	544	 +    ycoBottom = yco;
 	545	 +  }
 	546	 +  else {
 	547	 +    ycoTop = yco;
 	548	 +    ycoBottom = ycoOledCur;
 	549	 +  }
 	550	 +
 	551	 +
 	552	 +  while (ycoTop <= ycoBottom) {
 	553	 +    /* Compute the address of the left edge of the rectangle for this
 	554	 +    ** stripe across the rectangle.
 	555	 +    */
 	556	 +    pbLeft = &rgbOledBmp[((ycoTop/8) * ccolOledMax) + xcoLeft];
 	557	 +
 	558	 +    /* Generate a mask to preserve any low bits in the byte that aren't
 	559	 +    ** part of the rectangle being filled.
 	560	 +    */
 	561	 +    mskPat = (1 << (ycoTop & 0x07)) - 1;
 	562	 +
 	563	 +    /* Combine with a mask to preserve any upper bits in the byte that aren't
 	564	 +    ** part of the rectangle being filled.
 	565	 +    ** This mask will end up not preserving any bits for bytes that are in
 	566	 +    ** the middle of the rectangle vertically.
 	567	 +    */
 	568	 +    if ((ycoTop / 8) == (ycoBottom / 8)) {
 	569	 +      mskPat |= ~((1 << ((ycoBottom&0x07)+1)) - 1);
 	570	 +    }                      
 	571	 +    ibPat = xcoLeft & 0x07;    //index to first pattern byte
 	572	 +    xcoCur = xcoLeft;
 	573	 +    pbCur = pbLeft;
 	574	 +
 	575	 +    /* Loop through all of the bytes horizontally making up this stripe
 	576	 +    ** of the rectangle.
 	577	 +    */
 	578	 +    while (xcoCur <= xcoRight) {
 	579	 +      *pbCur = (*pfnDoRop)(*(pbOledPatCur+ibPat), *pbCur, ~mskPat);
 	580	 +      xcoCur += 1;
 	581	 +      pbCur += 1;
 	582	 +      ibPat += 1;
 	583	 +      if (ibPat > 7) {
 	584	 +        ibPat = 0;
 	585	 +      }
 	586	 +    }
 	587	 +
 	588	 +    /* Advance to the next horizontal stripe.
 	589	 +    */
 	590	 +    ycoTop = 8*((ycoTop/8)+1);
 	591	 +
 	592	 +  }
 	593	 +
 	594	 +}
 	595	 +
 	596	 +/* ------------------------------------------------------------ */
 	597	 +/***  OledGetBmp
 	598	 +**
 	599	 +**  Parameters:
 	600	 +**    dxco    - width of bitmap
 	601	 +**    dyco    - height of bitmap
 	602	 +**    pbBits    - pointer to the bitmap bits  
 	603	 +**
 	604	 +**  Return Value:
 	605	 +**    none
 	606	 +**
 	607	 +**  Errors:
 	608	 +**    none
 	609	 +**
 	610	 +**  Description:
 	611	 +**    This routine will get the bits corresponding to the
 	612	 +**    rectangle implied by the current location and the
 	613	 +**    specified width and height. The buffer specified
 	614	 +**    by pbBits must be large enough to hold the resulting
 	615	 +**    bytes.
 	616	 +*/
 	617	 +
 	618	 +void
 	619	 +OledGetBmp(int dxco, int dyco, BYTE * pbBits)
 	620	 +  {
 	621	 +  int    xcoLeft;
 	622	 +  int    xcoRight;
 	623	 +  int    ycoTop;
 	624	 +  int    ycoBottom;
 	625	 +  BYTE *  pbDspCur;
 	626	 +  BYTE *  pbDspLeft;
 	627	 +  BYTE *  pbBmpCur;
 	628	 +  BYTE *  pbBmpLeft;
 	629	 +  int    xcoCur;
 	630	 +  int    bnAlign;
 	631	 +  BYTE  mskEnd;
 	632	 +  BYTE  bTmp;
 	633	 +
 	634	 +  /* Set up the four sides of the source rectangle.
 	635	 +  */
 	636	 +  xcoLeft = xcoOledCur;
 	637	 +  xcoRight = xcoLeft + dxco;
 	638	 +  if (xcoRight >= ccolOledMax) {
 	639	 +    xcoRight = ccolOledMax - 1;
 	640	 +  }
 	641	 +
 	642	 +  ycoTop = ycoOledCur;
 	643	 +  ycoBottom = ycoTop + dyco;
 	644	 +  if (ycoBottom >= crowOledMax) {
 	645	 +    ycoBottom = crowOledMax - 1;
 	646	 +  }
 	647	 +
 	648	 +  bnAlign = ycoTop & 0x07;
 	649	 +  pbDspLeft = &rgbOledBmp[((ycoTop/8) * ccolOledMax) + xcoLeft];
 	650	 +  pbBmpLeft = pbBits;
 	651	 +
 	652	 +  while (ycoTop < ycoBottom) {
 	653	 +
 	654	 +    if ((ycoTop / 8) == ((ycoBottom-1) / 8)) {
 	655	 +      mskEnd = ((1 << (((ycoBottom-1)&0x07)+1)) - 1);
 	656	 +    }
 	657	 +    else {
 	658	 +      mskEnd = 0xFF;
 	659	 +    }
 	660	 +                      
 	661	 +    xcoCur = xcoLeft;
 	662	 +    pbDspCur = pbDspLeft;
 	663	 +    pbBmpCur = pbBmpLeft;
 	664	 +
 	665	 +    /* Loop through all of the bytes horizontally making up this stripe
 	666	 +    ** of the rectangle.
 	667	 +    */
 	668	 +    if (bnAlign == 0) {
 	669	 +      while (xcoCur < xcoRight) {
 	670	 +        *pbBmpCur = (*pbDspCur) & mskEnd;
 	671	 +        xcoCur += 1;
 	672	 +        pbBmpCur += 1;
 	673	 +        pbDspCur += 1;
 	674	 +      }
 	675	 +    }
 	676	 +    else {
 	677	 +      while (xcoCur < xcoRight) {
 	678	 +        bTmp = *pbDspCur;
 	679	 +        bTmp = *(pbDspCur+ccolOledMax);
 	680	 +        *pbBmpCur = ((*pbDspCur >> bnAlign) |
 	681	 +              ((*(pbDspCur+ccolOledMax)) << (8-bnAlign))) & mskEnd;
 	682	 +        xcoCur += 1;
 	683	 +        pbBmpCur += 1;
 	684	 +        pbDspCur += 1;
 	685	 +      }
 	686	 +    }
 	687	 +
 	688	 +    /* Advance to the next horizontal stripe.
 	689	 +    */
 	690	 +    ycoTop += 8;
 	691	 +    pbDspLeft += ccolOledMax;
 	692	 +    pbBmpLeft += dxco;
 	693	 +
 	694	 +  }
 	695	 +
 	696	 +}
 	697	 +
 	698	 +/* ------------------------------------------------------------ */
 	699	 +/***  OledPutBmp
 	700	 +**
 	701	 +**  Parameters:
 	702	 +**    dxco    - width of bitmap
 	703	 +**    dyco    - height of bitmap
 	704	 +**    pbBits    - pointer to the bitmap bits  
 	705	 +**
 	706	 +**  Return Value:
 	707	 +**    none
 	708	 +**
 	709	 +**  Errors:
 	710	 +**    none
 	711	 +**
 	712	 +**  Description:
 	713	 +**    This routine will put the specified bitmap into the display
 	714	 +**    buffer at the current location.
 	715	 +*/
 	716	 +
 	717	 +void
 	718	 +OledPutBmp(int dxco, int dyco, BYTE * pbBits)
 	719	 +  {
 	720	 +  int    xcoLeft;
 	721	 +  int    xcoRight;
 	722	 +  int    ycoTop;
 	723	 +  int    ycoBottom;
 	724	 +  BYTE *  pbDspCur;
 	725	 +  BYTE *  pbDspLeft;
 	726	 +  BYTE *  pbBmpCur;
 	727	 +  BYTE *  pbBmpLeft;
 	728	 +  int    xcoCur;
 	729	 +  BYTE  bDsp;
 	730	 +  BYTE  bBmp;
 	731	 +  BYTE  mskEnd;
 	732	 +  BYTE  mskUpper;
 	733	 +  BYTE  mskLower;
 	734	 +  int    bnAlign;
 	735	 +  int    fTop;
 	736	 +  BYTE  bTmp;
 	737	 +
 	738	 +  /* Set up the four sides of the destination rectangle.
 	739	 +  */
 	740	 +  xcoLeft = xcoOledCur;
 	741	 +  xcoRight = xcoLeft + dxco;
 	742	 +  if (xcoRight >= ccolOledMax) {
 	743	 +    xcoRight = ccolOledMax - 1;
 	744	 +  }
 	745	 +
 	746	 +  ycoTop = ycoOledCur;
 	747	 +  ycoBottom = ycoTop + dyco;
 	748	 +  if (ycoBottom >= crowOledMax) {
 	749	 +    ycoBottom = crowOledMax - 1;
 	750	 +  }
 	751	 +
 	752	 +  bnAlign = ycoTop & 0x07;
 	753	 +  mskUpper = (1 << bnAlign) - 1;
 	754	 +  mskLower = ~mskUpper;
 	755	 +  pbDspLeft = &rgbOledBmp[((ycoTop/8) * ccolOledMax) + xcoLeft];
 	756	 +  pbBmpLeft = pbBits;
 	757	 +  fTop = 1;
 	758	 +
 	759	 +  while (ycoTop < ycoBottom) {
 	760	 +    /* Combine with a mask to preserve any upper bits in the byte that aren't
 	761	 +    ** part of the rectangle being filled.
 	762	 +    ** This mask will end up not preserving any bits for bytes that are in
 	763	 +    ** the middle of the rectangle vertically.
 	764	 +    */
 	765	 +    if ((ycoTop / 8) == ((ycoBottom-1) / 8)) {
 	766	 +      mskEnd = ((1 << (((ycoBottom-1)&0x07)+1)) - 1);
 	767	 +    }
 	768	 +    else {
 	769	 +      mskEnd = 0xFF;
 	770	 +    }
 	771	 +    if (fTop) {
 	772	 +      mskEnd &= ~mskUpper;
 	773	 +    }
 	774	 +                      
 	775	 +    xcoCur = xcoLeft;
 	776	 +    pbDspCur = pbDspLeft;
 	777	 +    pbBmpCur = pbBmpLeft;
 	778	 +
 	779	 +    /* Loop through all of the bytes horizontally making up this stripe
 	780	 +    ** of the rectangle.
 	781	 +    */
 	782	 +    if (bnAlign == 0) {
 	783	 +      while (xcoCur < xcoRight) {
 	784	 +        *pbDspCur = (*pfnDoRop)(*pbBmpCur, *pbDspCur, mskEnd);
 	785	 +        xcoCur += 1;
 	786	 +        pbDspCur += 1;
 	787	 +        pbBmpCur += 1;
 	788	 +      }
 	789	 +    }
 	790	 +    else {
 	791	 +      while (xcoCur < xcoRight) {
 	792	 +        bBmp = ((*pbBmpCur) << bnAlign);
 	793	 +        if (!fTop) {
 	794	 +          bBmp |= ((*(pbBmpCur - dxco) >> (8-bnAlign)) & ~mskLower);
 	795	 +        }
 	796	 +        bBmp &= mskEnd;
 	797	 +        *pbDspCur = (*pfnDoRop)(bBmp, *pbDspCur, mskEnd);
 	798	 +        xcoCur += 1;
 	799	 +        pbDspCur += 1;
 	800	 +        pbBmpCur += 1;
 	801	 +      }
 	802	 +    }
 	803	 +
 	804	 +    /* Advance to the next horizontal stripe.
 	805	 +    */
 	806	 +    ycoTop = 8*((ycoTop/8)+1);
 	807	 +    pbDspLeft += ccolOledMax;
 	808	 +    pbBmpLeft += dxco;
 	809	 +    fTop = 0;
 	810	 +
 	811	 +  }
 	812	 +
 	813	 +}
 	814	 +
 	815	 +/* ------------------------------------------------------------ */
 	816	 +/***  OledDrawChar
 	817	 +**
 	818	 +**  Parameters:
 	819	 +**    ch      - character to write to display
 	820	 +**
 	821	 +**  Return Value:
 	822	 +**    none
 	823	 +**
 	824	 +**  Errors:
 	825	 +**    none
 	826	 +**
 	827	 +**  Description:
 	828	 +**    Write the specified character to the display at the current
 	829	 +**    cursor position and advance the cursor.
 	830	 +*/
 	831	 +
 	832	 +void
 	833	 +OledDrawChar(char ch)
 	834	 +  {
 	835	 +  BYTE *  pbFont;
 	836	 +  BYTE *  pbBmp;
 	837	 +  int    ib;
 	838	 +
 	839	 +  if ((ch & 0x80) != 0) {
 	840	 +    return;
 	841	 +  }
 	842	 +
 	843	 +  if (ch < chOledUserMax) {
 	844	 +    pbFont = pbOledFontUser + ch*cbOledChar;
 	845	 +  }
 	846	 +  else if ((ch & 0x80) == 0) {
 	847	 +    pbFont = pbOledFontCur + (ch-chOledUserMax) * cbOledChar;
 	848	 +  }
 	849	 +
 	850	 +  pbBmp = pbOledCur;
 	851	 +
 	852	 +  OledPutBmp(dxcoOledFontCur, dycoOledFontCur, pbFont);
 	853	 +
 	854	 +  xcoOledCur += dxcoOledFontCur;
 	855	 +
 	856	 +}
 	857	 +
 	858	 +/* ------------------------------------------------------------ */
 	859	 +/***  OledDrawString
 	860	 +**
 	861	 +**  Parameters:
 	862	 +**    sz    - pointer to the null terminated string
 	863	 +**
 	864	 +**  Return Value:
 	865	 +**    none
 	866	 +**
 	867	 +**  Errors:
 	868	 +**    none
 	869	 +**
 	870	 +**  Description:
 	871	 +**    Write the specified null terminated character string to the
 	872	 +**    display and advance the cursor.
 	873	 +*/
 	874	 +
 	875	 +void
 	876	 +OledDrawString(char * sz)
 	877	 +  {
 	878	 +
 	879	 +  while (*sz != '\0') {
 	880	 +    OledDrawChar(*sz);
 	881	 +    sz += 1;
 	882	 +  }
 	883	 +}
 	884	 +
 	885	 +/* ------------------------------------------------------------ */
 	886	 +/*        Internal Support Routines            */
 	887	 +/* ------------------------------------------------------------ */
 	888	 +/***  OledRopSet
 	889	 +**
 	890	 +**  Parameters:
 	891	 +**
 	892	 +**  Return Value:
 	893	 +**
 	894	 +**  Errors:
 	895	 +**
 	896	 +**  Description:
 	897	 +**
 	898	 +*/
 	899	 +
 	900	 +BYTE
 	901	 +OledRopSet(BYTE bPix, BYTE bDsp, BYTE mskPix)
 	902	 +  {
 	903	 +
 	904	 +  return (bDsp & ~mskPix) | (bPix & mskPix);
 	905	 +
 	906	 +}
 	907	 +
 	908	 +/* ------------------------------------------------------------ */
 	909	 +/***  OledRopOr
 	910	 +**
 	911	 +**  Parameters:
 	912	 +**
 	913	 +**  Return Value:
 	914	 +**
 	915	 +**  Errors:
 	916	 +**
 	917	 +**  Description:
 	918	 +**
 	919	 +*/
 	920	 +
 	921	 +BYTE
 	922	 +OledRopOr(BYTE bPix, BYTE bDsp, BYTE mskPix)
 	923	 +  {
 	924	 +
 	925	 +  return bDsp | (bPix & mskPix);
 	926	 +
 	927	 +}
 	928	 +
 	929	 +/* ------------------------------------------------------------ */
 	930	 +/***  OledRopAnd
 	931	 +**
 	932	 +**  Parameters:
 	933	 +**
 	934	 +**  Return Value:
 	935	 +**
 	936	 +**  Errors:
 	937	 +**
 	938	 +**  Description:
 	939	 +**
 	940	 +*/
 	941	 +
 	942	 +BYTE
 	943	 +OledRopAnd(BYTE bPix, BYTE bDsp, BYTE mskPix)
 	944	 +  {
 	945	 +
 	946	 +  return bDsp & (bPix & mskPix);
 	947	 +
 	948	 +}
 	949	 +
 	950	 +/* ------------------------------------------------------------ */
 	951	 +/***  OledRopXor
 	952	 +**
 	953	 +**  Parameters:
 	954	 +**
 	955	 +**  Return Value:
 	956	 +**
 	957	 +**  Errors:
 	958	 +**
 	959	 +**  Description:
 	960	 +**
 	961	 +*/
 	962	 +
 	963	 +BYTE
 	964	 +OledRopXor(BYTE bPix, BYTE bDsp, BYTE mskPix)
 	965	 +  {
 	966	 +
 	967	 +  return bDsp ^ (bPix & mskPix);
 	968	 +
 	969	 +}
 	970	 +
 	971	 +/* ------------------------------------------------------------ */
 	972	 +/***  OledMoveUp
 	973	 +**
 	974	 +**  Parameters:
 	975	 +**    none
 	976	 +**
 	977	 +**  Return Value:
 	978	 +**    none
 	979	 +**
 	980	 +**  Errors:
 	981	 +**    none
 	982	 +**
 	983	 +**  Description:
 	984	 +**    Updates global variables related to current position on the
 	985	 +**    display.
 	986	 +*/
 	987	 +
 	988	 +void
 	989	 +OledMoveUp()
 	990	 +  {
 	991	 +
 	992	 +  /* Go up one bit position in the current byte.
 	993	 +  */
 	994	 +  bnOledCur -= 1;
 	995	 +
 	996	 +  /* If we have gone off the end of the current byte
 	997	 +  ** go up 1 page.
 	998	 +  */
 	999	 +  if (bnOledCur < 0) {
 	1000	 +    bnOledCur = 7;
 	1001	 +    pbOledCur -= ccolOledMax;
 	1002	 +    /* If we have gone off of the top of the display,
 	1003	 +    ** go back down.
 	1004	 +    */
 	1005	 +    if (pbOledCur < rgbOledBmp) {
 	1006	 +      pbOledCur += ccolOledMax;
 	1007	 +    }
 	1008	 +  }
 	1009	 +}
 	1010	 +
 	1011	 +/* ------------------------------------------------------------ */
 	1012	 +/***  OledMoveDown
 	1013	 +**
 	1014	 +**  Parameters:
 	1015	 +**    none
 	1016	 +**
 	1017	 +**  Return Value:
 	1018	 +**    none
 	1019	 +**
 	1020	 +**  Errors:
 	1021	 +**    none
 	1022	 +**
 	1023	 +**  Description:
 	1024	 +**    Updates global variables related to current position on the
 	1025	 +**    display.
 	1026	 +*/
 	1027	 +
 	1028	 +void
 	1029	 +OledMoveDown()
 	1030	 +  {
 	1031	 +
 	1032	 +  /* Go down one bit position in the current byte.
 	1033	 +  */
 	1034	 +  bnOledCur += 1;
 	1035	 +
 	1036	 +  /* If we have gone off the end of the current byte,
 	1037	 +  ** go down one page in the display memory.
 	1038	 +  */
 	1039	 +  if (bnOledCur > 7) {
 	1040	 +    bnOledCur = 0;
 	1041	 +    pbOledCur += ccolOledMax;
 	1042	 +    /* If we have gone off the end of the display memory
 	1043	 +    ** go back up a page.
 	1044	 +    */
 	1045	 +    if (pbOledCur >= rgbOledBmp+cbOledDispMax) {
 	1046	 +      pbOledCur -= ccolOledMax;
 	1047	 +    }
 	1048	 +  }
 	1049	 +}
 	1050	 +
 	1051	 +/* ------------------------------------------------------------ */
 	1052	 +/***  OledMoveLeft
 	1053	 +**
 	1054	 +**  Parameters:
 	1055	 +**    none
 	1056	 +**
 	1057	 +**  Return Value:
 	1058	 +**    none
 	1059	 +**
 	1060	 +**  Errors:
 	1061	 +**    none
 	1062	 +**
 	1063	 +**  Description:
 	1064	 +**    Updates global variables related to current position on the
 	1065	 +**    display.
 	1066	 +*/
 	1067	 +
 	1068	 +void
 	1069	 +OledMoveLeft()
 	1070	 +  {
 	1071	 +
 	1072	 +  /* Are we at the left edge of the display already
 	1073	 +  */
 	1074	 +  if (((pbOledCur - rgbOledBmp) & (ccolOledMax-1)) == 0) {
 	1075	 +    return;
 	1076	 +  }
 	1077	 +
 	1078	 +  /* Not at the left edge, so go back one byte.
 	1079	 +  */
 	1080	 +  pbOledCur -= 1;
 	1081	 +
 	1082	 +}
 	1083	 +
 	1084	 +/* ------------------------------------------------------------ */
 	1085	 +/***  OledMoveRight
 	1086	 +**
 	1087	 +**  Parameters:
 	1088	 +**    none
 	1089	 +**
 	1090	 +**  Return Value:
 	1091	 +**    none
 	1092	 +**
 	1093	 +**  Errors:
 	1094	 +**    none
 	1095	 +**
 	1096	 +**  Description:
 	1097	 +**    Updates global variables related to current position on the
 	1098	 +**    display.
 	1099	 +*/
 	1100	 +
 	1101	 +void
 	1102	 +OledMoveRight()
 	1103	 +  {
 	1104	 +
 	1105	 +  /* Are we at the right edge of the display already
 	1106	 +  */
 	1107	 +  if (((pbOledCur-rgbOledBmp) & (ccolOledMax-1)) == (ccolOledMax-1)) {
 	1108	 +    return;
 	1109	 +  }
 	1110	 +
 	1111	 +  /* Not at the right edge, so go forward one byte
 	1112	 +  */
 	1113	 +  pbOledCur += 1;
 	1114	 +
 	1115	 +}
 	1116	 +
 	1117	 +/* ------------------------------------------------------------ */
 	1118	 +/***  OledClampXco
 	1119	 +**
 	1120	 +**  Parameters:
 	1121	 +**    xco    - x value to clamp
 	1122	 +**
 	1123	 +**  Return Value:
 	1124	 +**    Returns clamped x value
 	1125	 +**
 	1126	 +**  Errors:
 	1127	 +**    none
 	1128	 +**
 	1129	 +**  Description:
 	1130	 +**    This routine forces the x value to be on the display.
 	1131	 +*/
 	1132	 +
 	1133	 +int
 	1134	 +OledClampXco(int xco)
 	1135	 +  {
 	1136	 +  if (xco < 0) {
 	1137	 +    xco = 0;
 	1138	 +  }
 	1139	 +  if (xco >= ccolOledMax) {
 	1140	 +    xco = ccolOledMax-1;
 	1141	 +  }
 	1142	 +
 	1143	 +  return xco;
 	1144	 +
 	1145	 +}
 	1146	 +
 	1147	 +/* ------------------------------------------------------------ */
 	1148	 +/***  OledClampYco
 	1149	 +**
 	1150	 +**  Parameters:
 	1151	 +**    yco    - y value to clamp
 	1152	 +**
 	1153	 +**  Return Value:
 	1154	 +**    Returns clamped y value
 	1155	 +**
 	1156	 +**  Errors:
 	1157	 +**    none
 	1158	 +**
 	1159	 +**  Description:
 	1160	 +**    This routine forces the y value to be on the display.
 	1161	 +*/
 	1162	 +
 	1163	 +int
 	1164	 +OledClampYco(int yco)
 	1165	 +  {
 	1166	 +  if (yco < 0) {
 	1167	 +    yco = 0;
 	1168	 +  }
 	1169	 +  if (yco >= crowOledMax) {
 	1170	 +    yco = crowOledMax-1;
 	1171	 +  }
 	1172	 +
 	1173	 +  return yco;
 	1174	 +
 	1175	 +}
 	1176	 +
 	1177	 +/* ------------------------------------------------------------ */
 	1178	 +/***  ProcName
 	1179	 +**
 	1180	 +**  Parameters:
 	1181	 +**
 	1182	 +**  Return Value:
 	1183	 +**
 	1184	 +**  Errors:
 	1185	 +**
 	1186	 +**  Description:
 	1187	 +**
 	1188	 +*/
 	1189	 +
 	1190	 +/* ------------------------------------------------------------ */
 	1191	 +
 	1192	 +/************************************************************************/
 	1193	 +
87 ????? lib/IOShieldOled/utility/OledGrph.h View file @ 5a843cc
...	...	 @@ -0,0 +1,87 @@
 	1	 +/************************************************************************/
 	2	 +/*                                    */
 	3	 +/*  OledGrph.h  --  Declarations for OLED Graphics Routines        */
 	4	 +/*                                    */
 	5	 +/************************************************************************/
 	6	 +/*  Author:    Gene Apperson                      */
 	7	 +/*  Copyright 2011, Digilent Inc.                    */
 	8	 +/************************************************************************/
 	9	 +/*
 	10	 +  This library is free software; you can redistribute it and/or
 	11	 +  modify it under the terms of the GNU Lesser General Public
 	12	 +  License as published by the Free Software Foundation; either
 	13	 +  version 2.1 of the License, or (at your option) any later version.
 	14	 +
 	15	 +  This library is distributed in the hope that it will be useful,
 	16	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	17	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	18	 +  Lesser General Public License for more details.
 	19	 +
 	20	 +  You should have received a copy of the GNU Lesser General Public
 	21	 +  License along with this library; if not, write to the Free Software
 	22	 +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 	23	 +*/
 	24	 +/************************************************************************/
 	25	 +/*  File Description:                          */
 	26	 +/*                                    */
 	27	 +/*  Interface declarations for OledGrph.c                */
 	28	 +/*                                    */
 	29	 +/************************************************************************/
 	30	 +/*  Revision History:                          */
 	31	 +/*                                    */
 	32	 +/*  06/03/2011(GeneA): created                      */
 	33	 +/*                                    */
 	34	 +/************************************************************************/
 	35	 +
 	36	 +#if !defined(OLEDGRPH_H)
 	37	 +#define  OLEDGRPH_H
 	38	 +
 	39	 +/* ------------------------------------------------------------ */
 	40	 +/*          Miscellaneous Declarations          */
 	41	 +/* ------------------------------------------------------------ */
 	42	 +
 	43	 +
 	44	 +
 	45	 +/* ------------------------------------------------------------ */
 	46	 +/*          General Type Declarations          */
 	47	 +/* ------------------------------------------------------------ */
 	48	 +
 	49	 +/* ------------------------------------------------------------ */
 	50	 +/*          Object Class Declarations          */
 	51	 +/* ------------------------------------------------------------ */
 	52	 +
 	53	 +
 	54	 +
 	55	 +/* ------------------------------------------------------------ */
 	56	 +/*          Variable Declarations            */
 	57	 +/* ------------------------------------------------------------ */
 	58	 +
 	59	 +
 	60	 +
 	61	 +/* ------------------------------------------------------------ */
 	62	 +/*          Procedure Declarations            */
 	63	 +/* ------------------------------------------------------------ */
 	64	 +
 	65	 +void    OledSetDrawColor(uint8_t clr);
 	66	 +void    OledSetDrawMode(int mod);
 	67	 +int      OledGetDrawMode();
 	68	 +uint8_t *  OledGetStdPattern(int ipat);
 	69	 +void    OledSetFillPattern(uint8_t * pbPat);
 	70	 +
 	71	 +void  OledMoveTo(int xco, int yco);
 	72	 +void  OledGetPos(int * pxco, int * pyco);
 	73	 +void  OledDrawPixel();
 	74	 +uint8_t  OledGetPixel();
 	75	 +void  OledLineTo(int xco, int yco);
 	76	 +void  OledDrawRect(int xco, int yco);
 	77	 +void  OledFillRect(int xco, int yco);
 	78	 +void  OledGetBmp(int dxco, int dyco, uint8_t * pbBmp);
 	79	 +void  OledPutBmp(int dxco, int dyco, uint8_t * pbBmp);
 	80	 +void  OledDrawChar(char ch);
 	81	 +void  OledDrawString(char * sz);
 	82	 +
 	83	 +/* ------------------------------------------------------------ */
 	84	 +
 	85	 +#endif
 	86	 +
 	87	 +/************************************************************************/
309 ????? lib/LiquidCrystal/LiquidCrystal.cpp View file @ 5a843cc
...	...	 @@ -0,0 +1,309 @@
 	1	 +#include "LiquidCrystal.h"
 	2	 +
 	3	 +#include <stdio.h>
 	4	 +#include <string.h>
 	5	 +#include <inttypes.h>
 	6	 +#include "WProgram.h"
 	7	 +
 	8	 +// When the display powers up, it is configured as follows:
 	9	 +//
 	10	 +// 1. Display clear
 	11	 +// 2. Function set: 
 	12	 +//    DL = 1; 8-bit interface data 
 	13	 +//    N = 0; 1-line display 
 	14	 +//    F = 0; 5x8 dot character font 
 	15	 +// 3. Display on/off control: 
 	16	 +//    D = 0; Display off 
 	17	 +//    C = 0; Cursor off 
 	18	 +//    B = 0; Blinking off 
 	19	 +// 4. Entry mode set: 
 	20	 +//    I/D = 1; Increment by 1 
 	21	 +//    S = 0; No shift 
 	22	 +//
 	23	 +// Note, however, that resetting the Arduino doesn't reset the LCD, so we
 	24	 +// can't assume that its in that state when a sketch starts (and the
 	25	 +// LiquidCrystal constructor is called).
 	26	 +
 	27	 +LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
 	28	 +           uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
 	29	 +           uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
 	30	 +{
 	31	 +  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
 	32	 +}
 	33	 +
 	34	 +LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,
 	35	 +           uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
 	36	 +           uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
 	37	 +{
 	38	 +  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
 	39	 +}
 	40	 +
 	41	 +LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
 	42	 +           uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
 	43	 +{
 	44	 +  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
 	45	 +}
 	46	 +
 	47	 +LiquidCrystal::LiquidCrystal(uint8_t rs,  uint8_t enable,
 	48	 +           uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
 	49	 +{
 	50	 +  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
 	51	 +}
 	52	 +
 	53	 +void LiquidCrystal::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
 	54	 +       uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
 	55	 +       uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
 	56	 +{
 	57	 +  _rs_pin = rs;
 	58	 +  _rw_pin = rw;
 	59	 +  _enable_pin = enable;
 	60	 +  
 	61	 +  _data_pins[0] = d0;
 	62	 +  _data_pins[1] = d1;
 	63	 +  _data_pins[2] = d2;
 	64	 +  _data_pins[3] = d3; 
 	65	 +  _data_pins[4] = d4;
 	66	 +  _data_pins[5] = d5;
 	67	 +  _data_pins[6] = d6;
 	68	 +  _data_pins[7] = d7; 
 	69	 +
 	70	 +  pinMode(_rs_pin, OUTPUT);
 	71	 +  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
 	72	 +  if (_rw_pin != 255) { 
 	73	 +    pinMode(_rw_pin, OUTPUT);
 	74	 +  }
 	75	 +  pinMode(_enable_pin, OUTPUT);
 	76	 +  
 	77	 +  if (fourbitmode)
 	78	 +    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
 	79	 +  else 
 	80	 +    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
 	81	 +  
 	82	 +  begin(16, 1);  
 	83	 +}
 	84	 +
 	85	 +void LiquidCrystal::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
 	86	 +  if (lines > 1) {
 	87	 +    _displayfunction |= LCD_2LINE;
 	88	 +  }
 	89	 +  _numlines = lines;
 	90	 +  _currline = 0;
 	91	 +
 	92	 +  // for some 1 line displays you can select a 10 pixel high font
 	93	 +  if ((dotsize != 0) && (lines == 1)) {
 	94	 +    _displayfunction |= LCD_5x10DOTS;
 	95	 +  }
 	96	 +
 	97	 +  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
 	98	 +  // according to datasheet, we need at least 40ms after power rises above 2.7V
 	99	 +  // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
 	100	 +  delayMicroseconds(50000); 
 	101	 +  // Now we pull both RS and R/W low to begin commands
 	102	 +  digitalWrite(_rs_pin, LOW);
 	103	 +  digitalWrite(_enable_pin, LOW);
 	104	 +  if (_rw_pin != 255) { 
 	105	 +    digitalWrite(_rw_pin, LOW);
 	106	 +  }
 	107	 +  
 	108	 +  //put the LCD into 4 bit or 8 bit mode
 	109	 +  if (! (_displayfunction & LCD_8BITMODE)) {
 	110	 +    // this is according to the hitachi HD44780 datasheet
 	111	 +    // figure 24, pg 46
 	112	 +
 	113	 +    // we start in 8bit mode, try to set 4 bit mode
 	114	 +    write4bits(0x03);
 	115	 +    delayMicroseconds(4500); // wait min 4.1ms
 	116	 +
 	117	 +    // second try
 	118	 +    write4bits(0x03);
 	119	 +    delayMicroseconds(4500); // wait min 4.1ms
 	120	 +    
 	121	 +    // third go!
 	122	 +    write4bits(0x03); 
 	123	 +    delayMicroseconds(150);
 	124	 +
 	125	 +    // finally, set to 4-bit interface
 	126	 +    write4bits(0x02); 
 	127	 +  } else {
 	128	 +    // this is according to the hitachi HD44780 datasheet
 	129	 +    // page 45 figure 23
 	130	 +
 	131	 +    // Send function set command sequence
 	132	 +    command(LCD_FUNCTIONSET | _displayfunction);
 	133	 +    delayMicroseconds(4500);  // wait more than 4.1ms
 	134	 +
 	135	 +    // second try
 	136	 +    command(LCD_FUNCTIONSET | _displayfunction);
 	137	 +    delayMicroseconds(150);
 	138	 +
 	139	 +    // third go
 	140	 +    command(LCD_FUNCTIONSET | _displayfunction);
 	141	 +  }
 	142	 +
 	143	 +  // finally, set # lines, font size, etc.
 	144	 +  command(LCD_FUNCTIONSET | _displayfunction);  
 	145	 +
 	146	 +  // turn the display on with no cursor or blinking default
 	147	 +  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
 	148	 +  display();
 	149	 +
 	150	 +  // clear it off
 	151	 +  clear();
 	152	 +
 	153	 +  // Initialize to default text direction (for romance languages)
 	154	 +  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
 	155	 +  // set the entry mode
 	156	 +  command(LCD_ENTRYMODESET | _displaymode);
 	157	 +
 	158	 +}
 	159	 +
 	160	 +/********** high level commands, for the user! */
 	161	 +void LiquidCrystal::clear()
 	162	 +{
 	163	 +  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
 	164	 +  delayMicroseconds(2000);  // this command takes a long time!
 	165	 +}
 	166	 +
 	167	 +void LiquidCrystal::home()
 	168	 +{
 	169	 +  command(LCD_RETURNHOME);  // set cursor position to zero
 	170	 +  delayMicroseconds(2000);  // this command takes a long time!
 	171	 +}
 	172	 +
 	173	 +void LiquidCrystal::setCursor(uint8_t col, uint8_t row)
 	174	 +{
 	175	 +  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
 	176	 +  if ( row > _numlines ) {
 	177	 +    row = _numlines-1;    // we count rows starting w/0
 	178	 +  }
 	179	 +  
 	180	 +  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
 	181	 +}
 	182	 +
 	183	 +// Turn the display on/off (quickly)
 	184	 +void LiquidCrystal::noDisplay() {
 	185	 +  _displaycontrol &= ~LCD_DISPLAYON;
 	186	 +  command(LCD_DISPLAYCONTROL | _displaycontrol);
 	187	 +}
 	188	 +void LiquidCrystal::display() {
 	189	 +  _displaycontrol |= LCD_DISPLAYON;
 	190	 +  command(LCD_DISPLAYCONTROL | _displaycontrol);
 	191	 +}
 	192	 +
 	193	 +// Turns the underline cursor on/off
 	194	 +void LiquidCrystal::noCursor() {
 	195	 +  _displaycontrol &= ~LCD_CURSORON;
 	196	 +  command(LCD_DISPLAYCONTROL | _displaycontrol);
 	197	 +}
 	198	 +void LiquidCrystal::cursor() {
 	199	 +  _displaycontrol |= LCD_CURSORON;
 	200	 +  command(LCD_DISPLAYCONTROL | _displaycontrol);
 	201	 +}
 	202	 +
 	203	 +// Turn on and off the blinking cursor
 	204	 +void LiquidCrystal::noBlink() {
 	205	 +  _displaycontrol &= ~LCD_BLINKON;
 	206	 +  command(LCD_DISPLAYCONTROL | _displaycontrol);
 	207	 +}
 	208	 +void LiquidCrystal::blink() {
 	209	 +  _displaycontrol |= LCD_BLINKON;
 	210	 +  command(LCD_DISPLAYCONTROL | _displaycontrol);
 	211	 +}
 	212	 +
 	213	 +// These commands scroll the display without changing the RAM
 	214	 +void LiquidCrystal::scrollDisplayLeft(void) {
 	215	 +  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
 	216	 +}
 	217	 +void LiquidCrystal::scrollDisplayRight(void) {
 	218	 +  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
 	219	 +}
 	220	 +
 	221	 +// This is for text that flows Left to Right
 	222	 +void LiquidCrystal::leftToRight(void) {
 	223	 +  _displaymode |= LCD_ENTRYLEFT;
 	224	 +  command(LCD_ENTRYMODESET | _displaymode);
 	225	 +}
 	226	 +
 	227	 +// This is for text that flows Right to Left
 	228	 +void LiquidCrystal::rightToLeft(void) {
 	229	 +  _displaymode &= ~LCD_ENTRYLEFT;
 	230	 +  command(LCD_ENTRYMODESET | _displaymode);
 	231	 +}
 	232	 +
 	233	 +// This will 'right justify' text from the cursor
 	234	 +void LiquidCrystal::autoscroll(void) {
 	235	 +  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
 	236	 +  command(LCD_ENTRYMODESET | _displaymode);
 	237	 +}
 	238	 +
 	239	 +// This will 'left justify' text from the cursor
 	240	 +void LiquidCrystal::noAutoscroll(void) {
 	241	 +  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
 	242	 +  command(LCD_ENTRYMODESET | _displaymode);
 	243	 +}
 	244	 +
 	245	 +// Allows us to fill the first 8 CGRAM locations
 	246	 +// with custom characters
 	247	 +void LiquidCrystal::createChar(uint8_t location, uint8_t charmap[]) {
 	248	 +  location &= 0x7; // we only have 8 locations 0-7
 	249	 +  command(LCD_SETCGRAMADDR | (location << 3));
 	250	 +  for (int i=0; i<8; i++) {
 	251	 +    write(charmap[i]);
 	252	 +  }
 	253	 +}
 	254	 +
 	255	 +/*********** mid level commands, for sending data/cmds */
 	256	 +
 	257	 +inline void LiquidCrystal::command(uint8_t value) {
 	258	 +  send(value, LOW);
 	259	 +}
 	260	 +
 	261	 +inline void LiquidCrystal::write(uint8_t value) {
 	262	 +  send(value, HIGH);
 	263	 +}
 	264	 +
 	265	 +/************ low level data pushing commands **********/
 	266	 +
 	267	 +// write either command or data, with automatic 4/8-bit selection
 	268	 +void LiquidCrystal::send(uint8_t value, uint8_t mode) {
 	269	 +  digitalWrite(_rs_pin, mode);
 	270	 +
 	271	 +  // if there is a RW pin indicated, set it low to Write
 	272	 +  if (_rw_pin != 255) { 
 	273	 +    digitalWrite(_rw_pin, LOW);
 	274	 +  }
 	275	 +  
 	276	 +  if (_displayfunction & LCD_8BITMODE) {
 	277	 +    write8bits(value); 
 	278	 +  } else {
 	279	 +    write4bits(value>>4);
 	280	 +    write4bits(value);
 	281	 +  }
 	282	 +}
 	283	 +
 	284	 +void LiquidCrystal::pulseEnable(void) {
 	285	 +  digitalWrite(_enable_pin, LOW);
 	286	 +  delayMicroseconds(1);    
 	287	 +  digitalWrite(_enable_pin, HIGH);
 	288	 +  delayMicroseconds(1);    // enable pulse must be >450ns
 	289	 +  digitalWrite(_enable_pin, LOW);
 	290	 +  delayMicroseconds(100);   // commands need > 37us to settle
 	291	 +}
 	292	 +
 	293	 +void LiquidCrystal::write4bits(uint8_t value) {
 	294	 +  for (int i = 0; i < 4; i++) {
 	295	 +    pinMode(_data_pins[i], OUTPUT);
 	296	 +    digitalWrite(_data_pins[i], (value >> i) & 0x01);
 	297	 +  }
 	298	 +
 	299	 +  pulseEnable();
 	300	 +}
 	301	 +
 	302	 +void LiquidCrystal::write8bits(uint8_t value) {
 	303	 +  for (int i = 0; i < 8; i++) {
 	304	 +    pinMode(_data_pins[i], OUTPUT);
 	305	 +    digitalWrite(_data_pins[i], (value >> i) & 0x01);
 	306	 +  }
 	307	 +  
 	308	 +  pulseEnable();
 	309	 +}
104 ????? lib/LiquidCrystal/LiquidCrystal.h View file @ 5a843cc
...	...	 @@ -0,0 +1,104 @@
 	1	 +#ifndef LiquidCrystal_h
 	2	 +#define LiquidCrystal_h
 	3	 +
 	4	 +#include <inttypes.h>
 	5	 +#include "Print.h"
 	6	 +
 	7	 +// commands
 	8	 +#define LCD_CLEARDISPLAY 0x01
 	9	 +#define LCD_RETURNHOME 0x02
 	10	 +#define LCD_ENTRYMODESET 0x04
 	11	 +#define LCD_DISPLAYCONTROL 0x08
 	12	 +#define LCD_CURSORSHIFT 0x10
 	13	 +#define LCD_FUNCTIONSET 0x20
 	14	 +#define LCD_SETCGRAMADDR 0x40
 	15	 +#define LCD_SETDDRAMADDR 0x80
 	16	 +
 	17	 +// flags for display entry mode
 	18	 +#define LCD_ENTRYRIGHT 0x00
 	19	 +#define LCD_ENTRYLEFT 0x02
 	20	 +#define LCD_ENTRYSHIFTINCREMENT 0x01
 	21	 +#define LCD_ENTRYSHIFTDECREMENT 0x00
 	22	 +
 	23	 +// flags for display on/off control
 	24	 +#define LCD_DISPLAYON 0x04
 	25	 +#define LCD_DISPLAYOFF 0x00
 	26	 +#define LCD_CURSORON 0x02
 	27	 +#define LCD_CURSOROFF 0x00
 	28	 +#define LCD_BLINKON 0x01
 	29	 +#define LCD_BLINKOFF 0x00
 	30	 +
 	31	 +// flags for display/cursor shift
 	32	 +#define LCD_DISPLAYMOVE 0x08
 	33	 +#define LCD_CURSORMOVE 0x00
 	34	 +#define LCD_MOVERIGHT 0x04
 	35	 +#define LCD_MOVELEFT 0x00
 	36	 +
 	37	 +// flags for function set
 	38	 +#define LCD_8BITMODE 0x10
 	39	 +#define LCD_4BITMODE 0x00
 	40	 +#define LCD_2LINE 0x08
 	41	 +#define LCD_1LINE 0x00
 	42	 +#define LCD_5x10DOTS 0x04
 	43	 +#define LCD_5x8DOTS 0x00
 	44	 +
 	45	 +class LiquidCrystal : public Print {
 	46	 +public:
 	47	 +  LiquidCrystal(uint8_t rs, uint8_t enable,
 	48	 +    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
 	49	 +    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
 	50	 +  LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
 	51	 +    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
 	52	 +    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
 	53	 +  LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
 	54	 +    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
 	55	 +  LiquidCrystal(uint8_t rs, uint8_t enable,
 	56	 +    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
 	57	 +
 	58	 +  void init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
 	59	 +      uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
 	60	 +      uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
 	61	 +    
 	62	 +  void begin(uint8_t cols, uint8_t rows, uint8_t charsize = LCD_5x8DOTS);
 	63	 +
 	64	 +  void clear();
 	65	 +  void home();
 	66	 +
 	67	 +  void noDisplay();
 	68	 +  void display();
 	69	 +  void noBlink();
 	70	 +  void blink();
 	71	 +  void noCursor();
 	72	 +  void cursor();
 	73	 +  void scrollDisplayLeft();
 	74	 +  void scrollDisplayRight();
 	75	 +  void leftToRight();
 	76	 +  void rightToLeft();
 	77	 +  void autoscroll();
 	78	 +  void noAutoscroll();
 	79	 +
 	80	 +  void createChar(uint8_t, uint8_t[]);
 	81	 +  void setCursor(uint8_t, uint8_t); 
 	82	 +  virtual void write(uint8_t);
 	83	 +  void command(uint8_t);
 	84	 +private:
 	85	 +  void send(uint8_t, uint8_t);
 	86	 +  void write4bits(uint8_t);
 	87	 +  void write8bits(uint8_t);
 	88	 +  void pulseEnable();
 	89	 +
 	90	 +  uint8_t _rs_pin; // LOW: command.  HIGH: character.
 	91	 +  uint8_t _rw_pin; // LOW: write to LCD.  HIGH: read from LCD.
 	92	 +  uint8_t _enable_pin; // activated by a HIGH pulse.
 	93	 +  uint8_t _data_pins[8];
 	94	 +
 	95	 +  uint8_t _displayfunction;
 	96	 +  uint8_t _displaycontrol;
 	97	 +  uint8_t _displaymode;
 	98	 +
 	99	 +  uint8_t _initialized;
 	100	 +
 	101	 +  uint8_t _numlines,_currline;
 	102	 +};
 	103	 +
 	104	 +#endif
73 ????? lib/LiquidCrystal/examples/Autoscroll/Autoscroll.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,73 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - Autoscroll
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch demonstrates the use of the autoscroll()
 	10	 + and noAutoscroll() functions to make new text scroll or not.
 	11	 + 
 	12	 + The circuit:
 	13	 + * LCD RS pin to digital pin 12
 	14	 + * LCD Enable pin to digital pin 11
 	15	 + * LCD D4 pin to digital pin 5
 	16	 + * LCD D5 pin to digital pin 4
 	17	 + * LCD D6 pin to digital pin 3
 	18	 + * LCD D7 pin to digital pin 2
 	19	 + * LCD R/W pin to ground
 	20	 + * 10K resistor:
 	21	 + * ends to +5V and ground
 	22	 + * wiper to LCD VO pin (pin 3)
 	23	 + 
 	24	 + Library originally added 18 Apr 2008
 	25	 + by David A. Mellis
 	26	 + library modified 5 Jul 2009
 	27	 + by Limor Fried (http://www.ladyada.net)
 	28	 + example added 9 Jul 2009
 	29	 + by Tom Igoe 
 	30	 + modified 22 Nov 2010
 	31	 + by Tom Igoe
 	32	 + 
 	33	 + This example code is in the public domain.
 	34	 +
 	35	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	36	 + */
 	37	 +
 	38	 +// include the library code:
 	39	 +#include <LiquidCrystal.h>
 	40	 +
 	41	 +// initialize the library with the numbers of the interface pins
 	42	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	43	 +
 	44	 +void setup() {
 	45	 +  // set up the LCD's number of columns and rows: 
 	46	 +  lcd.begin(16,2);
 	47	 +}
 	48	 +
 	49	 +void loop() {
 	50	 +  // set the cursor to (0,0):
 	51	 +  lcd.setCursor(0, 0);
 	52	 +  // print from 0 to 9:
 	53	 +  for (int thisChar = 0; thisChar < 10; thisChar++) {
 	54	 +   lcd.print(thisChar);
 	55	 +   delay(500);
 	56	 +  }
 	57	 +
 	58	 +  // set the cursor to (16,1):
 	59	 +  lcd.setCursor(16,1);
 	60	 +  // set the display to automatically scroll:
 	61	 +  lcd.autoscroll();
 	62	 +  // print from 0 to 9:
 	63	 +  for (int thisChar = 0; thisChar < 10; thisChar++) {
 	64	 +    lcd.print(thisChar);
 	65	 +    delay(500);
 	66	 +  }
 	67	 +  // turn off automatic scrolling
 	68	 +  lcd.noAutoscroll();
 	69	 +  
 	70	 +  // clear screen for the next loop:
 	71	 +  lcd.clear();
 	72	 +}
 	73	 +
61 ????? lib/LiquidCrystal/examples/Blink/Blink.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,61 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - Blink
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch prints "Hello World!" to the LCD and makes the 
 	10	 + cursor block blink.
 	11	 + 
 	12	 + The circuit:
 	13	 + * LCD RS pin to digital pin 12
 	14	 + * LCD Enable pin to digital pin 11
 	15	 + * LCD D4 pin to digital pin 5
 	16	 + * LCD D5 pin to digital pin 4
 	17	 + * LCD D6 pin to digital pin 3
 	18	 + * LCD D7 pin to digital pin 2
 	19	 + * LCD R/W pin to ground
 	20	 + * 10K resistor:
 	21	 +   * ends to +5V and ground
 	22	 +   * wiper to LCD VO pin (pin 3)
 	23	 + 
 	24	 + Library originally added 18 Apr 2008
 	25	 + by David A. Mellis
 	26	 + library modified 5 Jul 2009
 	27	 + by Limor Fried (http://www.ladyada.net)
 	28	 + example added 9 Jul 2009
 	29	 + by Tom Igoe 
 	30	 + modified 22 Nov 2010
 	31	 + by Tom Igoe
 	32	 + 
 	33	 + This example code is in the public domain.
 	34	 +
 	35	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	36	 + 
 	37	 + */
 	38	 +
 	39	 +// include the library code:
 	40	 +#include <LiquidCrystal.h>
 	41	 +
 	42	 +// initialize the library with the numbers of the interface pins
 	43	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	44	 +
 	45	 +void setup() {
 	46	 +  // set up the LCD's number of columns and rows: 
 	47	 +  lcd.begin(16, 2);
 	48	 +  // Print a message to the LCD.
 	49	 +  lcd.print("hello, world!");
 	50	 +}
 	51	 +
 	52	 +void loop() {
 	53	 +  // Turn off the blinking cursor:
 	54	 +  lcd.noBlink();
 	55	 +  delay(3000);
 	56	 +   // Turn on the blinking cursor:
 	57	 +  lcd.blink();
 	58	 +  delay(3000);
 	59	 +}
 	60	 +
 	61	 +
60 ????? lib/LiquidCrystal/examples/Cursor/Cursor.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,60 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - Cursor
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch prints "Hello World!" to the LCD and
 	10	 + uses the cursor()  and noCursor() methods to turn
 	11	 + on and off the cursor.
 	12	 + 
 	13	 + The circuit:
 	14	 + * LCD RS pin to digital pin 12
 	15	 + * LCD Enable pin to digital pin 11
 	16	 + * LCD D4 pin to digital pin 5
 	17	 + * LCD D5 pin to digital pin 4
 	18	 + * LCD D6 pin to digital pin 3
 	19	 + * LCD D7 pin to digital pin 2
 	20	 + * LCD R/W pin to ground
 	21	 + * 10K resistor:
 	22	 + * ends to +5V and ground
 	23	 + * wiper to LCD VO pin (pin 3)
 	24	 + 
 	25	 + Library originally added 18 Apr 2008
 	26	 + by David A. Mellis
 	27	 + library modified 5 Jul 2009
 	28	 + by Limor Fried (http://www.ladyada.net)
 	29	 + example added 9 Jul 2009
 	30	 + by Tom Igoe 
 	31	 + modified 22 Nov 2010
 	32	 + by Tom Igoe
 	33	 +
 	34	 + This example code is in the public domain.
 	35	 +
 	36	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	37	 + */
 	38	 +
 	39	 +// include the library code:
 	40	 +#include <LiquidCrystal.h>
 	41	 +
 	42	 +// initialize the library with the numbers of the interface pins
 	43	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	44	 +
 	45	 +void setup() {
 	46	 +  // set up the LCD's number of columns and rows: 
 	47	 +  lcd.begin(16, 2);
 	48	 +  // Print a message to the LCD.
 	49	 +  lcd.print("hello, world!");
 	50	 +}
 	51	 +
 	52	 +void loop() {
 	53	 +  // Turn off the cursor:
 	54	 +  lcd.noCursor();
 	55	 +  delay(500);
 	56	 +   // Turn on the cursor:
 	57	 +  lcd.cursor();
 	58	 +  delay(500);
 	59	 +}
 	60	 +
60 ????? lib/LiquidCrystal/examples/Display/Display.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,60 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - display() and noDisplay()
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch prints "Hello World!" to the LCD and uses the 
 	10	 + display() and noDisplay() functions to turn on and off
 	11	 + the display.
 	12	 + 
 	13	 + The circuit:
 	14	 + * LCD RS pin to digital pin 12
 	15	 + * LCD Enable pin to digital pin 11
 	16	 + * LCD D4 pin to digital pin 5
 	17	 + * LCD D5 pin to digital pin 4
 	18	 + * LCD D6 pin to digital pin 3
 	19	 + * LCD D7 pin to digital pin 2
 	20	 + * LCD R/W pin to ground
 	21	 + * 10K resistor:
 	22	 + * ends to +5V and ground
 	23	 + * wiper to LCD VO pin (pin 3)
 	24	 + 
 	25	 + Library originally added 18 Apr 2008
 	26	 + by David A. Mellis
 	27	 + library modified 5 Jul 2009
 	28	 + by Limor Fried (http://www.ladyada.net)
 	29	 + example added 9 Jul 2009
 	30	 + by Tom Igoe 
 	31	 + modified 22 Nov 2010
 	32	 + by Tom Igoe
 	33	 +
 	34	 + This example code is in the public domain.
 	35	 +
 	36	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	37	 + */
 	38	 +
 	39	 +// include the library code:
 	40	 +#include <LiquidCrystal.h>
 	41	 +
 	42	 +// initialize the library with the numbers of the interface pins
 	43	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	44	 +
 	45	 +void setup() {
 	46	 +  // set up the LCD's number of columns and rows: 
 	47	 +  lcd.begin(16, 2);
 	48	 +  // Print a message to the LCD.
 	49	 +  lcd.print("hello, world!");
 	50	 +}
 	51	 +
 	52	 +void loop() {
 	53	 +  // Turn off the display:
 	54	 +  lcd.noDisplay();
 	55	 +  delay(500);
 	56	 +   // Turn on the display:
 	57	 +  lcd.display();
 	58	 +  delay(500);
 	59	 +}
 	60	 +
58 ????? lib/LiquidCrystal/examples/HelloWorld/HelloWorld.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,58 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - Hello World
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch prints "Hello World!" to the LCD
 	10	 + and shows the time.
 	11	 + 
 	12	 +  The circuit:
 	13	 + * LCD RS pin to digital pin 12
 	14	 + * LCD Enable pin to digital pin 11
 	15	 + * LCD D4 pin to digital pin 5
 	16	 + * LCD D5 pin to digital pin 4
 	17	 + * LCD D6 pin to digital pin 3
 	18	 + * LCD D7 pin to digital pin 2
 	19	 + * LCD R/W pin to ground
 	20	 + * 10K resistor:
 	21	 + * ends to +5V and ground
 	22	 + * wiper to LCD VO pin (pin 3)
 	23	 + 
 	24	 + Library originally added 18 Apr 2008
 	25	 + by David A. Mellis
 	26	 + library modified 5 Jul 2009
 	27	 + by Limor Fried (http://www.ladyada.net)
 	28	 + example added 9 Jul 2009
 	29	 + by Tom Igoe
 	30	 + modified 22 Nov 2010
 	31	 + by Tom Igoe
 	32	 + 
 	33	 + This example code is in the public domain.
 	34	 +
 	35	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	36	 + */
 	37	 +
 	38	 +// include the library code:
 	39	 +#include <LiquidCrystal.h>
 	40	 +
 	41	 +// initialize the library with the numbers of the interface pins
 	42	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	43	 +
 	44	 +void setup() {
 	45	 +  // set up the LCD's number of columns and rows: 
 	46	 +  lcd.begin(16, 2);
 	47	 +  // Print a message to the LCD.
 	48	 +  lcd.print("hello, world!");
 	49	 +}
 	50	 +
 	51	 +void loop() {
 	52	 +  // set the cursor to column 0, line 1
 	53	 +  // (note: line 1 is the second row, since counting begins with 0):
 	54	 +  lcd.setCursor(0, 1);
 	55	 +  // print the number of seconds since reset:
 	56	 +  lcd.print(millis()/1000);
 	57	 +}
 	58	 +
85 ????? lib/LiquidCrystal/examples/Scroll/Scroll.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,85 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - scrollDisplayLeft() and scrollDisplayRight()
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch prints "Hello World!" to the LCD and uses the
 	10	 + scrollDisplayLeft() and scrollDisplayRight() methods to scroll
 	11	 + the text.
 	12	 + 
 	13	 +  The circuit:
 	14	 + * LCD RS pin to digital pin 12
 	15	 + * LCD Enable pin to digital pin 11
 	16	 + * LCD D4 pin to digital pin 5
 	17	 + * LCD D5 pin to digital pin 4
 	18	 + * LCD D6 pin to digital pin 3
 	19	 + * LCD D7 pin to digital pin 2
 	20	 + * LCD R/W pin to ground
 	21	 + * 10K resistor:
 	22	 + * ends to +5V and ground
 	23	 + * wiper to LCD VO pin (pin 3)
 	24	 + 
 	25	 + Library originally added 18 Apr 2008
 	26	 + by David A. Mellis
 	27	 + library modified 5 Jul 2009
 	28	 + by Limor Fried (http://www.ladyada.net)
 	29	 + example added 9 Jul 2009
 	30	 + by Tom Igoe 
 	31	 + modified 22 Nov 2010
 	32	 + by Tom Igoe
 	33	 + 
 	34	 + This example code is in the public domain.
 	35	 + 
 	36	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	37	 + */
 	38	 +
 	39	 +// include the library code:
 	40	 +#include <LiquidCrystal.h>
 	41	 +
 	42	 +// initialize the library with the numbers of the interface pins
 	43	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	44	 +
 	45	 +void setup() {
 	46	 +  // set up the LCD's number of columns and rows: 
 	47	 +  lcd.begin(16, 2);
 	48	 +  // Print a message to the LCD.
 	49	 +  lcd.print("hello, world!");
 	50	 +  delay(1000);
 	51	 +}
 	52	 +
 	53	 +void loop() {
 	54	 +  // scroll 13 positions (string length) to the left 
 	55	 +  // to move it offscreen left:
 	56	 +  for (int positionCounter = 0; positionCounter < 13; positionCounter++) {
 	57	 +    // scroll one position left:
 	58	 +    lcd.scrollDisplayLeft(); 
 	59	 +    // wait a bit:
 	60	 +    delay(150);
 	61	 +  }
 	62	 +
 	63	 +  // scroll 29 positions (string length + display length) to the right
 	64	 +  // to move it offscreen right:
 	65	 +  for (int positionCounter = 0; positionCounter < 29; positionCounter++) {
 	66	 +    // scroll one position right:
 	67	 +    lcd.scrollDisplayRight(); 
 	68	 +    // wait a bit:
 	69	 +    delay(150);
 	70	 +  }
 	71	 +  
 	72	 +    // scroll 16 positions (display length + string length) to the left
 	73	 +    // to move it back to center:
 	74	 +  for (int positionCounter = 0; positionCounter < 16; positionCounter++) {
 	75	 +    // scroll one position left:
 	76	 +    lcd.scrollDisplayLeft(); 
 	77	 +    // wait a bit:
 	78	 +    delay(150);
 	79	 +  }
 	80	 +  
 	81	 +  // delay at the end of the full loop:
 	82	 +  delay(1000);
 	83	 +
 	84	 +}
 	85	 +
65 ????? lib/LiquidCrystal/examples/SerialDisplay/SerialDisplay.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,65 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - Serial Input
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch displays text sent over the serial port 
 	10	 + (e.g. from the Serial Monitor) on an attached LCD.
 	11	 + 
 	12	 + The circuit:
 	13	 + * LCD RS pin to digital pin 12
 	14	 + * LCD Enable pin to digital pin 11
 	15	 + * LCD D4 pin to digital pin 5
 	16	 + * LCD D5 pin to digital pin 4
 	17	 + * LCD D6 pin to digital pin 3
 	18	 + * LCD D7 pin to digital pin 2
 	19	 + * LCD R/W pin to ground
 	20	 + * 10K resistor:
 	21	 + * ends to +5V and ground
 	22	 + * wiper to LCD VO pin (pin 3)
 	23	 + 
 	24	 + Library originally added 18 Apr 2008
 	25	 + by David A. Mellis
 	26	 + library modified 5 Jul 2009
 	27	 + by Limor Fried (http://www.ladyada.net)
 	28	 + example added 9 Jul 2009
 	29	 + by Tom Igoe 
 	30	 + modified 22 Nov 2010
 	31	 + by Tom Igoe
 	32	 + 
 	33	 + This example code is in the public domain.
 	34	 + 
 	35	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	36	 + */
 	37	 +
 	38	 +// include the library code:
 	39	 +#include <LiquidCrystal.h>
 	40	 +
 	41	 +// initialize the library with the numbers of the interface pins
 	42	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	43	 +
 	44	 +void setup(){
 	45	 +    // set up the LCD's number of columns and rows: 
 	46	 +  lcd.begin(16, 2);
 	47	 +  // initialize the serial communications:
 	48	 +  Serial.begin(9600);
 	49	 +}
 	50	 +
 	51	 +void loop()
 	52	 +{
 	53	 +  // when characters arrive over the serial port...
 	54	 +  if (Serial.available()) {
 	55	 +    // wait a bit for the entire message to arrive
 	56	 +    delay(100);
 	57	 +    // clear the screen
 	58	 +    lcd.clear();
 	59	 +    // read all the available characters
 	60	 +    while (Serial.available() > 0) {
 	61	 +      // display each character to the LCD
 	62	 +      lcd.write(Serial.read());
 	63	 +    }
 	64	 +  }
 	65	 +}
87 ????? lib/LiquidCrystal/examples/TextDirection/TextDirection.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,87 @@
 	1	 +  /*
 	2	 +  LiquidCrystal Library - TextDirection
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch demonstrates how to use leftToRight() and rightToLeft()
 	10	 + to move the cursor.
 	11	 + 
 	12	 + The circuit:
 	13	 + * LCD RS pin to digital pin 12
 	14	 + * LCD Enable pin to digital pin 11
 	15	 + * LCD D4 pin to digital pin 5
 	16	 + * LCD D5 pin to digital pin 4
 	17	 + * LCD D6 pin to digital pin 3
 	18	 + * LCD D7 pin to digital pin 2
 	19	 + * LCD R/W pin to ground
 	20	 + * 10K resistor:
 	21	 + * ends to +5V and ground
 	22	 + * wiper to LCD VO pin (pin 3)
 	23	 + 
 	24	 + Library originally added 18 Apr 2008
 	25	 + by David A. Mellis
 	26	 + library modified 5 Jul 2009
 	27	 + by Limor Fried (http://www.ladyada.net)
 	28	 + example added 9 Jul 2009
 	29	 + by Tom Igoe 
 	30	 + modified 22 Nov 2010
 	31	 + by Tom Igoe
 	32	 + 
 	33	 + This example code is in the public domain.
 	34	 + 
 	35	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	36	 + 
 	37	 + */
 	38	 +
 	39	 +// include the library code:
 	40	 +#include <LiquidCrystal.h>
 	41	 +
 	42	 +// initialize the library with the numbers of the interface pins
 	43	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	44	 +
 	45	 +int thisChar = 'a';
 	46	 +
 	47	 +void setup() {
 	48	 +  // set up the LCD's number of columns and rows: 
 	49	 +  lcd.begin(16, 2);
 	50	 +  // turn on the cursor:
 	51	 +  lcd.cursor();
 	52	 +  Serial.begin(9600);
 	53	 +}
 	54	 +
 	55	 +void loop() {
 	56	 +  // reverse directions at 'm':
 	57	 +  if (thisChar == 'm') {
 	58	 +    // go right for the next letter
 	59	 +    lcd.rightToLeft(); 
 	60	 +  }
 	61	 +  // reverse again at 's':
 	62	 +  if (thisChar == 's') {
 	63	 +    // go left for the next letter
 	64	 +    lcd.leftToRight(); 
 	65	 +  }
 	66	 +  // reset at 'z':
 	67	 +  if (thisChar > 'z') {
 	68	 +    // go to (0,0):
 	69	 +    lcd.home(); 
 	70	 +    // start again at 0
 	71	 +    thisChar = 'a';
 	72	 +  }
 	73	 +  // print the character
 	74	 +  lcd.print(thisChar, BYTE);
 	75	 +  // wait a second:
 	76	 +  delay(1000);
 	77	 +  // increment the letter:
 	78	 +  thisChar++;
 	79	 +}
 	80	 +
 	81	 +
 	82	 +
 	83	 +
 	84	 +
 	85	 +
 	86	 +
 	87	 +
71 ????? lib/LiquidCrystal/examples/setCursor/setCursor.pde View file @ 5a843cc
...	...	 @@ -0,0 +1,71 @@
 	1	 +/*
 	2	 +  LiquidCrystal Library - setCursor
 	3	 + 
 	4	 + Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 	5	 + library works with all LCD displays that are compatible with the 
 	6	 + Hitachi HD44780 driver. There are many of them out there, and you
 	7	 + can usually tell them by the 16-pin interface.
 	8	 + 
 	9	 + This sketch prints to all the positions of the LCD using the
 	10	 + setCursor(0 method:
 	11	 + 
 	12	 +  The circuit:
 	13	 + * LCD RS pin to digital pin 12
 	14	 + * LCD Enable pin to digital pin 11
 	15	 + * LCD D4 pin to digital pin 5
 	16	 + * LCD D5 pin to digital pin 4
 	17	 + * LCD D6 pin to digital pin 3
 	18	 + * LCD D7 pin to digital pin 2
 	19	 + * LCD R/W pin to ground
 	20	 + * 10K resistor:
 	21	 + * ends to +5V and ground
 	22	 + * wiper to LCD VO pin (pin 3)
 	23	 + 
 	24	 + Library originally added 18 Apr 2008
 	25	 + by David A. Mellis
 	26	 + library modified 5 Jul 2009
 	27	 + by Limor Fried (http://www.ladyada.net)
 	28	 + example added 9 Jul 2009
 	29	 + by Tom Igoe 
 	30	 + modified 22 Nov 2010
 	31	 + by Tom Igoe
 	32	 + 
 	33	 + This example code is in the public domain.
 	34	 + 
 	35	 + http://www.arduino.cc/en/Tutorial/LiquidCrystal
 	36	 + */
 	37	 +
 	38	 +// include the library code:
 	39	 +#include <LiquidCrystal.h>
 	40	 +
 	41	 +// these constants won't change.  But you can change the size of
 	42	 +// your LCD using them:
 	43	 +const int numRows = 2;
 	44	 +const int numCols = 16;
 	45	 +
 	46	 +// initialize the library with the numbers of the interface pins
 	47	 +LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
 	48	 +
 	49	 +void setup() {
 	50	 +  // set up the LCD's number of columns and rows: 
 	51	 +  lcd.begin(numCols,numRows);
 	52	 +}
 	53	 +
 	54	 +void loop() {
 	55	 +  // loop from ASCII 'a' to ASCII 'z':
 	56	 +  for (int thisLetter = 'a'; thisLetter <= 'z'; thisLetter++) {
 	57	 +    // loop over the columns:
 	58	 +    for (int thisCol = 0; thisCol < numRows; thisCol++) {
 	59	 +      // loop over the rows:
 	60	 +      for (int thisRow = 0; thisRow < numCols; thisRow++) {
 	61	 +        // set the cursor position:
 	62	 +        lcd.setCursor(thisRow,thisCol);
 	63	 +        // print the letter:
 	64	 +        lcd.print(thisLetter, BYTE);
 	65	 +        delay(200);
 	66	 +      }
 	67	 +    }
 	68	 +  }
 	69	 +}
 	70	 +
 	71	 +
37 ????? lib/LiquidCrystal/keywords.txt View file @ 5a843cc
...	...	 @@ -0,0 +1,37 @@
 	1	 +#######################################
 	2	 +# Syntax Coloring Map For LiquidCrystal
 	3	 +#######################################
 	4	 +
 	5	 +#######################################
 	6	 +# Datatypes (KEYWORD1)
 	7	 +#######################################
 	8	 +
 	9	 +LiquidCrystal  KEYWORD1
 	10	 +
 	11	 +#######################################
 	12	 +# Methods and Functions (KEYWORD2)
 	13	 +#######################################
 	14	 +
 	15	 +begin  KEYWORD2
 	16	 +clear  KEYWORD2
 	17	 +home  KEYWORD2
 	18	 +print  KEYWORD2
 	19	 +setCursor  KEYWORD2
 	20	 +cursor  KEYWORD2
 	21	 +noCursor  KEYWORD2
 	22	 +blink  KEYWORD2
 	23	 +noBlink  KEYWORD2
 	24	 +display  KEYWORD2
 	25	 +noDisplay  KEYWORD2
 	26	 +autoscroll  KEYWORD2
 	27	 +noAutoscroll  KEYWORD2
 	28	 +leftToRight  KEYWORD2
 	29	 +rightToLeft  KEYWORD2
 	30	 +scrollDisplayLeft  KEYWORD2
 	31	 +scrollDisplayRight  KEYWORD2
 	32	 +createChar  KEYWORD2
 	33	 +
 	34	 +#######################################
 	35	 +# Constants (LITERAL1)
 	36	 +#######################################
 	37	 +
443 ????? lib/Morse_EnDecoder/MorseEnDecoder.cpp View file @ 5a843cc
...	...	 @@ -0,0 +1,443 @@
 	1	 +/*          MORSE ENDECODER
 	2	 + 
 	3	 + - Morse encoder / decoder classes for the Arduino.
 	4	 +
 	5	 + Copyright (C) 2010-2012 raron
 	6	 +
 	7	 + GNU GPLv3 license:
 	8	 +
 	9	 + This program is free software: you can redistribute it and/or modify
 	10	 + it under the terms of the GNU General Public License as published by
 	11	 + the Free Software Foundation, either version 3 of the License, or
 	12	 + (at your option) any later version.
 	13	 + 
 	14	 + This program is distributed in the hope that it will be useful,
 	15	 + but WITHOUT ANY WARRANTY; without even the implied warranty of
 	16	 + MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 	17	 + GNU General Public License for more details.
 	18	 + 
 	19	 + You should have received a copy of the GNU General Public License
 	20	 + along with this program.  If not, see <http://www.gnu.org/licenses/>.
 	21	 + 
 	22	 +
 	23	 + Contact: raronzen@gmail.com
 	24	 + Details: http://raronoff.wordpress.com/2010/12/16/morse-endecoder/
 	25	 +
 	26	 + TODO:
 	27	 + - have this table in PROGMEM! DONE!
 	28	 + - Get rid of debounce for keying input - *NOT DONE* was needed!
 	29	 + - Use micros() for faster timings
 	30	 + - use different defines for different morse code tables, up to including 9-signal SOS etc
 	31	 + - Speed auto sense? (unlikely, but would be nice).
 	32	 + - Serial command parser example sketch (to change speed and settings etc) 
 	33	 + - LOOK AT UNDERSCORE SEND-BUG (is sent as questionmark)! *DONE* Fixed!
 	34	 + 
 	35	 +
 	36	 + History:
 	37	 + 2012.11.22 - Debugged the _underscore_ problem, it got "uppercased" to a
 	38	 +                question mark. Also, included ampersand (&)
 	39	 + 2012.11.20 - Finally moved table to PROGMEM! Cleaned up header comments a bit.
 	40	 + 2012.11.10 - Fixed minor bug: pinMode for the Morse output pin (thanks Rezoss!)
 	41	 + 2012.01.31 - Tiny update for Arduino 1.0. Fixed header comments.
 	42	 + 2010.12.06 - Cleaned up code a bit.
 	43	 +                Added the "MN digraph" ---. for alternate exclamation mark(!).
 	44	 +                Still encoded as the "KW digraph" -.-.-- though.
 	45	 + 2010.12.04 - Program changed to use (Decode and Encode) classes instead.
 	46	 + 2010.12.02 - Changed back to signed timers to avoid overflow.
 	47	 + 2010.11.30 - Morse punctuation added (except $ - the dollar sign).
 	48	 + 2010.11.29 - Added echo on/off command.
 	49	 + 2010.11.28 - Added simple Morse audio clipping filter + Command parser.
 	50	 + 2010.11.27 - Added Morse encoding via reverse-dichotomic path tracing.
 	51	 +                Thus using the same Morse tree for encoding and decoding.
 	52	 + 2010.11.11 - Complete Rewrite for the Arduino.
 	53	 + 1992.01.06 - My old rather unknown "Morse decoder 3.5" for Amiga 600.
 	54	 +                A 68000 Assembler version using a binary tree for Morse
 	55	 +                decoding only, of which this is based on.
 	56	 +*/ 
 	57	 +
 	58	 +#include "MorseEnDecoder.h"
 	59	 +
 	60	 +// Morse code binary tree table (or, dichotomic search table)
 	61	 +
 	62	 +// ITU - International Morse code table only
 	63	 +//const int morseTreetop = 31;
 	64	 +//char morseTable[] = "5H4S?V3I?F?U??2E?L?R???A?P?W?J1 6B?D?X?N?C?K?Y?T7Z?G?Q?M8??O9?0";
 	65	 +
 	66	 +
 	67	 +// ITU with punctuation (but without non-english characters - for now)
 	68	 +const int morseTreetop = 63;
 	69	 +char morseTable[] PROGMEM = "*5*H*4*S***V*3*I***F***U?*_**2*E*&*L\"**R*+.****A***P@**W***J'1* *6-B*=*D*/"
 	70	 +                    "*X***N***C;*!K*()Y***T*7*Z**,G***Q***M:8*!***O*9***0*";
 	71	 +
 	72	 +
 	73	 +const int morseTableLength = (morseTreetop*2)+1;
 	74	 +const int morseTreeLevels = log(morseTreetop+1)/log(2);
 	75	 +
 	76	 +
 	77	 +
 	78	 +morseDecoder::morseDecoder(int decodePin, boolean listenAudio, boolean morsePullup)
 	79	 +{
 	80	 +  morseInPin = decodePin;
 	81	 +  morseAudio = listenAudio;
 	82	 +  activeLow = morsePullup;
 	83	 +
 	84	 +  if (morseAudio == false)
 	85	 +  {
 	86	 +    pinMode(morseInPin, INPUT);
 	87	 +    if (activeLow) digitalWrite (morseInPin, HIGH);
 	88	 +  }
 	89	 +
 	90	 +  // Some initial values  
 	91	 +  wpm = 13;
 	92	 +  AudioThreshold = 700;
 	93	 +  debounceDelay = 20;
 	94	 +  dotTime = 1200 / wpm;       // morse dot time length in ms
 	95	 +  dashTime = 3 * 1200 / wpm;
 	96	 +  wordSpace = 7 * 1200 / wpm;
 	97	 +
 	98	 +  morseTableJumper = (morseTreetop+1)/2;
 	99	 +  morseTablePointer = morseTreetop;
 	100	 + 
 	101	 +  morseKeyer = LOW;
 	102	 +  morseSignalState = LOW;
 	103	 +  lastKeyerState = LOW;
 	104	 +
 	105	 +  gotLastSig = true;
 	106	 +  morseSpace = true;
 	107	 +  decodedMorseChar = '\0';
 	108	 +  
 	109	 +  lastDebounceTime = 0;
 	110	 +  markTime = 0;
 	111	 +  spaceTime = 0;
 	112	 +}
 	113	 +
 	114	 +
 	115	 +
 	116	 +void morseDecoder::setspeed(int value)
 	117	 +{
 	118	 +  wpm = value;
 	119	 +  if (wpm <= 0) wpm = 1;
 	120	 +  dotTime = 1200 / wpm;
 	121	 +  dashTime = 3 * 1200 / wpm;
 	122	 +  wordSpace = 7 * 1200 / wpm;
 	123	 +}
 	124	 +
 	125	 +
 	126	 +
 	127	 +boolean morseDecoder::available()
 	128	 +{
 	129	 +  if (decodedMorseChar) return true; else return false;
 	130	 +}
 	131	 +
 	132	 +
 	133	 +
 	134	 +char morseDecoder::read()
 	135	 +{
 	136	 +  char temp = decodedMorseChar;
 	137	 +  decodedMorseChar = '\0';
 	138	 +  return temp;
 	139	 +}
 	140	 +
 	141	 +
 	142	 +
 	143	 +
 	144	 +
 	145	 +morseEncoder::morseEncoder(int encodePin)
 	146	 +{
 	147	 +  morseOutPin = encodePin;
 	148	 +  pinMode(morseOutPin, OUTPUT);
 	149	 +
 	150	 +  // some initial values
 	151	 +  digitalWrite (morseOutPin, LOW);
 	152	 +  sendingMorse = false;
 	153	 +  encodeMorseChar = '\0';
 	154	 +
 	155	 +  wpm = 13;
 	156	 +  dotTime = 1200 / wpm;       // morse dot time length in ms
 	157	 +  dashTime = 3 * 1200 / wpm;
 	158	 +  wordSpace = 7 * 1200 / wpm;
 	159	 + 
 	160	 +}
 	161	 +
 	162	 +
 	163	 +
 	164	 +void morseEncoder::setspeed(int value)
 	165	 +{
 	166	 +  wpm = value;
 	167	 +  if (wpm <= 0) wpm = 1;
 	168	 +  dotTime = 1200 / wpm;
 	169	 +  dashTime = 3 * 1200 / wpm;
 	170	 +  wordSpace = 7 * 1200 / wpm;
 	171	 +}
 	172	 +
 	173	 +
 	174	 +
 	175	 +boolean morseEncoder::available()
 	176	 +{
 	177	 +  if (sendingMorse) return false; else return true;
 	178	 +}
 	179	 +
 	180	 +
 	181	 +
 	182	 +void morseEncoder::write(char temp)
 	183	 +{
 	184	 +  if (!sendingMorse && temp != '*') encodeMorseChar = temp;
 	185	 +}
 	186	 +
 	187	 +
 	188	 +
 	189	 + 
 	190	 +
 	191	 +void morseDecoder::decode()
 	192	 +{
 	193	 +  currentTime = millis();
 	194	 +  
 	195	 +  // Read Morse signals
 	196	 +  if (morseAudio == false)
 	197	 +  {
 	198	 +    // Read the Morse keyer (digital)
 	199	 +    morseKeyer = digitalRead(morseInPin);
 	200	 +    if (activeLow) morseKeyer = !morseKeyer;
 	201	 +
 	202	 +    // If the switch changed, due to noise or pressing:
 	203	 +    if (morseKeyer != lastKeyerState) lastDebounceTime = currentTime; // reset timer
 	204	 +  
 	205	 +    // debounce the morse keyer
 	206	 +    if ((currentTime - lastDebounceTime) > debounceDelay)
 	207	 +    {
 	208	 +      // whatever the reading is at, it's been there for longer
 	209	 +      // than the debounce delay, so take it as the actual current state:
 	210	 +      morseSignalState = morseKeyer;
 	211	 +      
 	212	 +      // differentiante mark and space times
 	213	 +      if (morseSignalState) markTime = lastDebounceTime; 
 	214	 +      else spaceTime = lastDebounceTime;
 	215	 +    }
 	216	 +  } else {
 	217	 +    // Read Morse audio signal
 	218	 +    audioSignal = analogRead(morseInPin);
 	219	 +    if (audioSignal > AudioThreshold)
 	220	 +    {
 	221	 +      // If this is a new morse signal, reset morse signal timer
 	222	 +      if (currentTime - lastDebounceTime > dotTime/2)
 	223	 +      {
 	224	 +        markTime = currentTime;
 	225	 +        morseSignalState = true; // there is currently a Morse signal
 	226	 +      }
 	227	 +      lastDebounceTime = currentTime;
 	228	 +    } else {
 	229	 +      // if this is a new pause, reset space time
 	230	 +      if (currentTime - lastDebounceTime > dotTime/2 && morseSignalState == true)
 	231	 +      {
 	232	 +        spaceTime = lastDebounceTime; // not too far off from last received audio
 	233	 +        morseSignalState = false;     // No more signal
 	234	 +      }
 	235	 +    }
 	236	 +  }
 	237	 +  
 	238	 +
 	239	 +
 	240	 +  // Decode morse code
 	241	 +  if (!morseSignalState)
 	242	 +  {
 	243	 +    if (!gotLastSig)
 	244	 +    {
 	245	 +      if (morseTableJumper > 0)
 	246	 +      {
 	247	 +        // if pause for more than half a dot, get what kind of signal pulse (dot/dash) received last
 	248	 +        if (currentTime - spaceTime > dotTime/2)
 	249	 +        {
 	250	 +          // if signal for more than 1/4 dotTime, take it as a morse pulse
 	251	 +          if (spaceTime-markTime > dotTime/4)
 	252	 +          {
 	253	 +            // if signal for less than half a dash, take it as a dot
 	254	 +            if (spaceTime-markTime < dashTime/2)
 	255	 +            {
 	256	 +               morseTablePointer -= morseTableJumper;
 	257	 +               morseTableJumper /= 2;
 	258	 +               gotLastSig = true;
 	259	 +            }
 	260	 +            // else if signal for between half a dash and a dash + one dot (1.33 dashes), take as a dash
 	261	 +            else if (spaceTime-markTime < dashTime + dotTime)
 	262	 +            {
 	263	 +              morseTablePointer += morseTableJumper;
 	264	 +              morseTableJumper /= 2;
 	265	 +              gotLastSig = true;
 	266	 +            }
 	267	 +          }
 	268	 +        }
 	269	 +      } else { // error if too many pulses in one morse character
 	270	 +        //Serial.println("<ERROR: unrecognized signal!>");
 	271	 +        decodedMorseChar = '#'; // error mark
 	272	 +        gotLastSig = true;
 	273	 +        morseTableJumper = (morseTreetop+1)/2;
 	274	 +        morseTablePointer = morseTreetop;
 	275	 +      }
 	276	 +    }
 	277	 +    // Write out the character if pause is longer than 2/3 dash time (2 dots) and a character received
 	278	 +    if ((currentTime-spaceTime >= (dotTime*2)) && (morseTableJumper < ((morseTreetop+1)/2)))
 	279	 +    {
 	280	 +      decodedMorseChar = pgm_read_byte_near(morseTable + morseTablePointer);
 	281	 +      morseTableJumper = (morseTreetop+1)/2;
 	282	 +      morseTablePointer = morseTreetop;
 	283	 +    }
 	284	 +    // Write a space if pause is longer than 2/3rd wordspace
 	285	 +    if (currentTime-spaceTime > (wordSpace*2/3) && morseSpace == false)
 	286	 +    {
 	287	 +      //Serial.print(" ");
 	288	 +      decodedMorseChar = ' ';
 	289	 +      morseSpace = true ; // space written-flag
 	290	 +    }
 	291	 +
 	292	 +  } else {
 	293	 +    // while there is a signal, reset some flags
 	294	 +    gotLastSig = false;
 	295	 +    morseSpace = false;
 	296	 +  }
 	297	 +  
 	298	 +  // Save the morse keyer state for next round
 	299	 +  lastKeyerState = morseKeyer;
 	300	 +}
 	301	 +
 	302	 +
 	303	 +
 	304	 +
 	305	 +
 	306	 +
 	307	 +
 	308	 +void morseEncoder::encode()
 	309	 +{
 	310	 +  currentTime = millis();
 	311	 +
 	312	 +  if (!sendingMorse && encodeMorseChar)
 	313	 +  {
 	314	 +    // change to capital letter if not
 	315	 +    if (encodeMorseChar > 96) encodeMorseChar -= 32;
 	316	 +  
 	317	 +    // Scan for the character to send in the Morse table
 	318	 +    int i;
 	319	 +    for (i=0; i<morseTableLength; i++) if (pgm_read_byte_near(morseTable + i) == encodeMorseChar) break;
 	320	 +    int morseTablePos = i+1;  // 1-based position
 	321	 +  
 	322	 +    // Reverse dichotomic / binary tree path tracing
 	323	 +  
 	324	 +    // Find out what level in the binary tree the character is
 	325	 +    int test;
 	326	 +    for (i=0; i<morseTreeLevels; i++)
 	327	 +    {
 	328	 +      test = (morseTablePos + (0x0001 << i)) % (0x0002 << i);
 	329	 +      if (test == 0) break;
 	330	 +    }
 	331	 +    int startLevel = i;
 	332	 +    morseSignals = morseTreeLevels - i; // = the number of dots and/or dashes
 	333	 +    morseSignalPos = 0;
 	334	 +  
 	335	 +    // Travel the reverse path to the top of the morse table
 	336	 +    if (morseSignals > 0)
 	337	 +    {
 	338	 +      // build the morse signal (backwards from last signal to first)
 	339	 +      for (i = startLevel; i<morseTreeLevels; i++)
 	340	 +      {
 	341	 +        int add = (0x0001 << i);
 	342	 +        test = (morseTablePos + add) / (0x0002 << i);
 	343	 +        if (test & 0x0001 == 1)
 	344	 +        {
 	345	 +          morseTablePos += add;
 	346	 +          // Add a dot to the temporary morse signal string
 	347	 +          morseSignalString[morseSignals-1 - morseSignalPos++] = '.';
 	348	 +        } else {
 	349	 +          morseTablePos -= add;
 	350	 +          // Add a dash to the temporary morse signal string
 	351	 +          morseSignalString[morseSignals-1 - morseSignalPos++] = '-';
 	352	 +        }
 	353	 +      }
 	354	 +    } else {  // unless it was on the top to begin with (A space character)
 	355	 +      morseSignalString[0] = ' ';
 	356	 +      morseSignalPos = 1;
 	357	 +      morseSignals = 1; // cheating a little; a wordspace for a "morse signal"
 	358	 +    }
 	359	 +    morseSignalString[morseSignalPos] = '\0';
 	360	 +  
 	361	 +  /*
 	362	 +    if (morseTablePos-1 != morseTreetop)
 	363	 +    {
 	364	 +      Serial.println();
 	365	 +      Serial.print("..Hm..error? MorseTablePos = ");
 	366	 +      Serial.println(morseTablePos); 
 	367	 +    }
 	368	 +  */
 	369	 +  
 	370	 +    // start sending the the character
 	371	 +    sendingMorse = true;
 	372	 +    sendingMorseSignalNr = 0;
 	373	 +    sendMorseTimer = currentTime;
 	374	 +    if (morseSignalString[0] != ' ') digitalWrite(morseOutPin, HIGH);
 	375	 +  }
 	376	 +
 	377	 +
 	378	 +  // Send Morse signals to output
 	379	 +  if (sendingMorse)
 	380	 +  {
 	381	 +    switch (morseSignalString[sendingMorseSignalNr])
 	382	 +    {
 	383	 +      case '.': // Send a dot (actually, stop sending a signal after a "dot time")
 	384	 +        if (currentTime - sendMorseTimer >= dotTime)
 	385	 +        {
 	386	 +          digitalWrite(morseOutPin, LOW);
 	387	 +          sendMorseTimer = currentTime;
 	388	 +          morseSignalString[sendingMorseSignalNr] = 'x'; // Mark the signal as sent
 	389	 +        }
 	390	 +        break;
 	391	 +      case '-': // Send a dash (same here, stop sending after a dash worth of time)
 	392	 +        if (currentTime - sendMorseTimer >= dashTime)
 	393	 +        {
 	394	 +          digitalWrite(morseOutPin, LOW);
 	395	 +          sendMorseTimer = currentTime;
 	396	 +          morseSignalString[sendingMorseSignalNr] = 'x'; // Mark the signal as sent
 	397	 +        }
 	398	 +        break;
 	399	 +      case 'x': // To make sure there is a pause between signals and letters
 	400	 +        if (sendingMorseSignalNr < morseSignals-1)
 	401	 +        {
 	402	 +          // Pause between signals in the same letter
 	403	 +          if (currentTime - sendMorseTimer >= dotTime)
 	404	 +          {
 	405	 +            sendingMorseSignalNr++;
 	406	 +            digitalWrite(morseOutPin, HIGH); // Start sending the next signal
 	407	 +            sendMorseTimer = currentTime;       // reset the timer
 	408	 +          }
 	409	 +        } else {
 	410	 +          // Pause between letters
 	411	 +          if (currentTime - sendMorseTimer >= dashTime)
 	412	 +          {
 	413	 +            sendingMorseSignalNr++;
 	414	 +            sendMorseTimer = currentTime;       // reset the timer
 	415	 +          }
 	416	 +        }
 	417	 +        break;
 	418	 +      case ' ': // Pause between words (minus pause between letters - already sent)
 	419	 +      default:  // Just in case its something else
 	420	 +        if (currentTime - sendMorseTimer > wordSpace - dashTime) sendingMorseSignalNr++;
 	421	 +    }
 	422	 +    if (sendingMorseSignalNr >= morseSignals)
 	423	 +    {
 	424	 +      // Ready to encode more letters
 	425	 +      sendingMorse = false;
 	426	 +      encodeMorseChar = '\0';
 	427	 +    }
 	428	 +  }
 	429	 +}
 	430	 +
 	431	 +
 	432	 +
 	433	 +
 	434	 +
 	435	 +
 	436	 +
 	437	 +
 	438	 +
 	439	 +
 	440	 +
 	441	 +
 	442	 +
 	443	 +
80 ????? lib/Morse_EnDecoder/MorseEnDecoder.h View file @ 5a843cc
...	...	 @@ -0,0 +1,80 @@
 	1	 +#ifndef MorseEnDecoder_H
 	2	 +#define MorseEnDecoder_H
 	3	 +
 	4	 +#if (ARDUINO <  100)
 	5	 +#include <WProgram.h>
 	6	 +#else
 	7	 +#include <Arduino.h>
 	8	 +#endif
 	9	 +
 	10	 +#define MORSE_AUDIO true
 	11	 +#define MORSE_KEYER false
 	12	 +#define MORSE_ACTIVE_LOW true
 	13	 +#define MORSE_ACTIVE_HIGH false
 	14	 +
 	15	 +
 	16	 +class morseDecoder
 	17	 +{
 	18	 +  public:
 	19	 +    morseDecoder(int decodePin, boolean listenAudio, boolean morsePullup);
 	20	 +    void decode();
 	21	 +    void setspeed(int value);
 	22	 +    char read();
 	23	 +    boolean available();
 	24	 +    int AudioThreshold;
 	25	 +    long debounceDelay;     // the debounce time. Keep well below dotTime!!
 	26	 +    boolean morseSignalState;  
 	27	 +  private:
 	28	 +    int morseInPin;         // The Morse input pin
 	29	 +    int audioSignal;
 	30	 +    int morseTableJumper;
 	31	 +    int morseTablePointer;
 	32	 +    int wpm;                // Word-per-minute speed
 	33	 +    long dotTime;           // morse dot time length in ms
 	34	 +    long dashTime;
 	35	 +    long wordSpace;
 	36	 +    boolean morseSpace;     // Flag to prevent multiple received spaces
 	37	 +    boolean gotLastSig;     // Flag that the last received morse signal is decoded as dot or dash
 	38	 +    boolean morseKeyer;
 	39	 +    boolean lastKeyerState;
 	40	 +    boolean morseAudio;
 	41	 +    boolean activeLow;
 	42	 +    long markTime;          // timers for mark and space in morse signal
 	43	 +    long spaceTime;         // E=MC^2 ;p
 	44	 +    long lastDebounceTime;  // the last time the input pin was toggled
 	45	 +    long currentTime;       // The current (signed) time
 	46	 +    char decodedMorseChar;  // The last decoded Morse character
 	47	 +};
 	48	 +
 	49	 +
 	50	 +
 	51	 +
 	52	 +class morseEncoder
 	53	 +{
 	54	 +  public:
 	55	 +    morseEncoder(int encodePin);
 	56	 +    void encode();
 	57	 +    void setspeed(int value);
 	58	 +    void write(char temp);
 	59	 +    boolean available();
 	60	 +    char morseSignalString[7];// Morse signal for one character as temporary ASCII string of dots and dashes
 	61	 +  private:
 	62	 +    char encodeMorseChar;   // ASCII character to encode
 	63	 +    int morseOutPin;
 	64	 +    boolean sendingMorse;
 	65	 +    int wpm;                // Word-per-minute speed
 	66	 +    long dotTime;           // morse dot time length in ms
 	67	 +    long dashTime;
 	68	 +    long wordSpace;
 	69	 +    int morseSignals;       // nr of morse signals to send in one morse character
 	70	 +    int morseSignalPos;
 	71	 +    int sendingMorseSignalNr;
 	72	 +    long sendMorseTimer;
 	73	 +    long lastDebounceTime;
 	74	 +    long currentTime;
 	75	 +};
 	76	 +
 	77	 +
 	78	 +#endif
 	79	 +
 	80	 +
67 ????? lib/Morse_EnDecoder/examples/Morse_EnDecoder_barebones/Morse_EnDecoder_barebones.ino View file @ 5a843cc
...	...	 @@ -0,0 +1,67 @@
 	1	 +/*
 	2	 +           MORSE ENDECODER BAREBONES
 	3	 +
 	4	 +  Minimum sketch to send/receive Morse code via the serial monitor.
 	5	 +
 	6	 +  This example decodes Morse signals present on digital input 7
 	7	 +    (active low, and then also using the internal pullup resistor).
 	8	 +  It also encodes Morse sent via the serial interface to the Arduino,
 	9	 +    on digital output pin 13.
 	10	 +
 	11	 +  Copyright (C) 2010, 2012 raron
 	12	 +  GNU GPLv3 license (http://www.gnu.org/licenses)
 	13	 +  Contact: raronzen@gmail.com  (not checked too often..)
 	14	 +  Details: http://raronoff.wordpress.com/2010/12/16/morse-endecoder/
 	15	 +*/
 	16	 +
 	17	 +#include <avr/pgmspace.h>
 	18	 +#include <MorseEnDecoder.h>
 	19	 +
 	20	 +// Pin mapping
 	21	 +const byte morseInPin = 7;      
 	22	 +const byte morseOutPin = 13;
 	23	 +
 	24	 +// Instantiate Morse objects
 	25	 +morseDecoder morseInput(morseInPin, MORSE_KEYER, MORSE_ACTIVE_LOW);
 	26	 +morseEncoder morseOutput(morseOutPin);
 	27	 +
 	28	 +void setup()
 	29	 +{
 	30	 +  Serial.begin(9600);
 	31	 +  Serial.println("Morse EnDecoder barebones demo");
 	32	 +  
 	33	 +  // Setting Morse speed in wpm - words per minute
 	34	 +  // If not set, 13 wpm is default anyway
 	35	 +  morseInput.setspeed(13);
 	36	 +  morseOutput.setspeed(13);
 	37	 +}
 	38	 +
 	39	 +
 	40	 +void loop()
 	41	 +{
 	42	 +  // Need to call these once per loop
 	43	 +  morseInput.decode();
 	44	 +  morseOutput.encode();
 	45	 +
 	46	 +  // SEND MORSE (OUTPUT)
 	47	 +  // Encode and send text received from the serial port (serial monitor)
 	48	 +  if (Serial.available() && morseOutput.available())
 	49	 +  {
 	50	 +    // Get character from serial and send as Morse code
 	51	 +    char sendMorse = Serial.read();
 	52	 +    morseOutput.write(sendMorse);
 	53	 +  }
 	54	 +
 	55	 +  // RECEIVE MORSE (INPUT)
 	56	 +  // If a character is decoded from the input, write it to serial port
 	57	 +  if (morseInput.available())
 	58	 +  {
 	59	 +    char receivedMorse = morseInput.read();
 	60	 +    Serial.print(receivedMorse);
 	61	 +    
 	62	 +    // A little error checking    
 	63	 +    if (receivedMorse == '#') Serial.println("< ERROR:too many morse signals! >");
 	64	 +  }
 	65	 +
 	66	 +}
 	67	 +
148 ????? lib/Morse_EnDecoder/examples/Morse_EnDecoder_demo/Morse_EnDecoder_demo.ino View file @ 5a843cc
...	...	 @@ -0,0 +1,148 @@
 	1	 +/*
 	2	 +                MORSE ENDECODER DEMO
 	3	 +
 	4	 +  Demonstrates using Morse encoder and decoder classes for the Arduino.
 	5	 +
 	6	 +  Local Morse code feedback to both serial and Morse output (unless sending 
 	7	 +    at the same time as receiving or keying in morse), for morse training demo.
 	8	 +  Formatted serial port output - Serial monitor looks a bit nicer.
 	9	 +
 	10	 +
 	11	 +  This example decodes Morse code signals with a speed of 13 WPM present on
 	12	 +    digital input 7 (active low, and also using the internal pullup resistor).
 	13	 +
 	14	 +  It also encodes Morse code sent via the serial interface to the Arduino,
 	15	 +    on digital output pin 13. Speed is 13 WPM also (easily changed in code).
 	16	 +  
 	17	 +  It can also decode audible signals, if using the constant MORSE_AUDIO
 	18	 +    instead of MORSE_KEYER, but then it is important to note that the
 	19	 +    input pin nr. will be for ANALOG inputs (0-5 on Atmega 168 - 328),
 	20	 +    and not the digital inputs.
 	21	 +
 	22	 +
 	23	 +
 	24	 +  Copyright (C) 2010, 2012 raron
 	25	 +  
 	26	 +  GNU GPLv3 license:
 	27	 +  
 	28	 +  This program is free software: you can redistribute it and/or modify
 	29	 +  it under the terms of the GNU General Public License as published by
 	30	 +  the Free Software Foundation, either version 3 of the License, or
 	31	 +  (at your option) any later version.
 	32	 +   
 	33	 +  This program is distributed in the hope that it will be useful,
 	34	 +  but WITHOUT ANY WARRANTY; without even the implied warranty of
 	35	 +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 	36	 +  GNU General Public License for more details.
 	37	 +   
 	38	 +  You should have received a copy of the GNU General Public License
 	39	 +  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 	40	 +   
 	41	 +  
 	42	 +  Contact: raronzen@gmail.com  (not checked too often..)
 	43	 +  Details: http://raronoff.wordpress.com/2010/12/16/morse-endecoder/
 	44	 +*/
 	45	 +
 	46	 +#include <avr/pgmspace.h>
 	47	 +#include <MorseEnDecoder.h>
 	48	 +
 	49	 +// Pin mappings
 	50	 +const byte morseInPin = 7;      
 	51	 +const byte morseOutPin = 13;
 	52	 +
 	53	 +// Instantiate Morse objects
 	54	 +morseDecoder morseInput(morseInPin, MORSE_KEYER, MORSE_ACTIVE_LOW);
 	55	 +morseEncoder morseOutput(morseOutPin);
 	56	 +
 	57	 +// Variables dealing with formatting the output somewhat
 	58	 +// by inserting CR's (carriage returns)
 	59	 +long lastTransmissionTime;
 	60	 +long currentTime;
 	61	 +boolean transmissionEnded = true; // Flag to mark old transmission is finished
 	62	 +
 	63	 +// Minimum transmission pause time to insert carriage returns (CR)
 	64	 +// Adjust depending on Morse speed. IE 13 wpm = 646 ms between words (no CR).
 	65	 +const long transmissionPaused   = 1000; // Suitable for 13 wpm?
 	66	 +
 	67	 +
 	68	 +void setup()
 	69	 +{
 	70	 +  Serial.begin(9600);
 	71	 +  Serial.println("Morse EnDecoder demo");
 	72	 +  
 	73	 +  // Setting Morse speed in wpm - words per minute
 	74	 +  // If not set, 13 wpm is default anyway
 	75	 +  morseInput.setspeed(13);
 	76	 +  morseOutput.setspeed(13);
 	77	 +  
 	78	 +  lastTransmissionTime = (long)millis();
 	79	 +}
 	80	 +
 	81	 +
 	82	 +
 	83	 +void loop()
 	84	 +{
 	85	 +  currentTime = (long)millis();
 	86	 +  
 	87	 +  // Needs to call these once per loop
 	88	 +  morseInput.decode();
 	89	 +  morseOutput.encode();
 	90	 +
 	91	 +  // SEND MORSE (OUTPUT)
 	92	 +  // Encode and send text received from the serial port (serial monitor)
 	93	 +  if (Serial.available() && morseOutput.available())
 	94	 +  {
 	95	 +    // Get character from serial and send as Morse code
 	96	 +    char sendMorse = Serial.read();
 	97	 +    morseOutput.write(sendMorse);
 	98	 +    
 	99	 +    // Not strictly needed, but used to get morseSignalString before it is destroyed
 	100	 +    // (E.g. for morse training purposes)
 	101	 +    morseOutput.encode();
 	102	 +
 	103	 +    // Also write sent character + Morse code to serial port/monitor
 	104	 +    Serial.write(' ');
 	105	 +    Serial.write(sendMorse);
 	106	 +    Serial.write(morseOutput.morseSignalString);
 	107	 +  }
 	108	 +
 	109	 +
 	110	 +  // RECEIVE MORSE (INPUT)
 	111	 +  // If a character is decoded from the input, write it to serial port
 	112	 +  if (morseInput.available())
 	113	 +  {
 	114	 +    // Get decoded Morse code character and write it to serial port/monitor
 	115	 +    char receivedMorse = morseInput.read();
 	116	 +    Serial.print(receivedMorse);
 	117	 +    
 	118	 +    // A little error checking    
 	119	 +    if (receivedMorse == '#') Serial.println("< ERROR:too many morse signals! >");
 	120	 +  }
 	121	 +
 	122	 +
 	123	 +  // Local Morse code feedback from input if not sending Morse simultaneously
 	124	 +  if (morseOutput.available()) digitalWrite(morseOutPin, morseInput.morseSignalState);
 	125	 +
 	126	 +
 	127	 +  // Check if ongoing transmission (not yet transmission pause)
 	128	 +  if (!morseOutput.available() || morseInput.morseSignalState == true)
 	129	 +  {
 	130	 +    // reset last transmission timer and flag
 	131	 +    lastTransmissionTime = currentTime;
 	132	 +    transmissionEnded = false;
 	133	 +  }
 	134	 +
 	135	 +  // Format output with carriage returns after a transmission pause
 	136	 +  if ((currentTime - lastTransmissionTime) > transmissionPaused)
 	137	 +  {
 	138	 +    if (transmissionEnded == false)
 	139	 +    {
 	140	 +      // Separate the transmissions somewhat in the serial monitor with CR's
 	141	 +      for (int cr=0; cr<2; cr++) Serial.println("");  // some carriage returns..
 	142	 +      
 	143	 +      // Finally set the flag to prevent continous carriage returns
 	144	 +      transmissionEnded = true;
 	145	 +    }
 	146	 +  }
 	147	 +}
 	148	 +
31 ????? lib/Morse_EnDecoder/keywords.txt View file @ 5a843cc
...	...	 @@ -0,0 +1,31 @@
 	1	 +#######################################
 	2	 +# Syntax Coloring Map For MorseEnDecoder
 	3	 +#######################################
 	4	 +
 	5	 +#######################################
 	6	 +# Datatypes (KEYWORD1)
 	7	 +#######################################
 	8	 +
 	9	 +morseDecoder  KEYWORD1
 	10	 +morseEncoder  KEYWORD1
 	11	 +
 	12	 +#######################################
 	13	 +# Methods and Functions (KEYWORD2)
 	14	 +#######################################
 	15	 +decode  KEYWORD2
 	16	 +encode  KEYWORD2
 	17	 +setspeed  KEYWORD2
 	18	 +read  KEYWORD2
 	19	 +write  KEYWORD2
 	20	 +available  KEYWORD2
 	21	 +
 	22	 +
 	23	 +#######################################
 	24	 +# Constants (LITERAL1)
 	25	 +#######################################
 	26	 +
 	27	 +MORSE_AUDIO  LITERAL1
 	28	 +MORSE_KEYER  LITERAL1
 	29	 +MORSE_ACTIVE_LOW  LITERAL1
 	30	 +MORSE_ACTIVE_HIGH  LITERAL1
 	31	 +
0 notes on commit 5a843cc Show line notes below
Please sign in to comment.
Status API Training Shop Blog About  2013 GitHub, Inc. Terms Privacy Security Contact 